<?php
/**
 * EntryTypeDto
 *
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Model;

use \ArrayAccess;
use \Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * EntryTypeDto Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EntryTypeDto implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'EntryTypeDto';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'entry_type_id' => 'string',
        'disable_receipt' => 'string',
        'module' => 'string',
        'default_offset_account_branch' => 'object',
        'default_offset_account' => 'object',
        'default_offset_subaccount' => 'object',
        'reclasification_account' => 'object',
        'business_account' => 'object',
        'description' => 'string',
        'use_for_payments_reclasification' => 'bool',
        'reclasification_account_override' => 'object',
        'offset_account_override' => 'object',
        'offset_subaccount_override' => 'object',
        'offset_account_branch' => 'object',
        'vat_zone' => 'object',
        'tax_calculation_mode' => 'string',
        'last_modified_date_time' => '\DateTime'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'entry_type_id' => null,
        'disable_receipt' => null,
        'module' => null,
        'default_offset_account_branch' => null,
        'default_offset_account' => null,
        'default_offset_subaccount' => null,
        'reclasification_account' => null,
        'business_account' => null,
        'description' => null,
        'use_for_payments_reclasification' => null,
        'reclasification_account_override' => null,
        'offset_account_override' => null,
        'offset_subaccount_override' => null,
        'offset_account_branch' => null,
        'vat_zone' => null,
        'tax_calculation_mode' => null,
        'last_modified_date_time' => 'date-time'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'entry_type_id' => 'entryTypeId',
        'disable_receipt' => 'disableReceipt',
        'module' => 'module',
        'default_offset_account_branch' => 'defaultOffsetAccountBranch',
        'default_offset_account' => 'defaultOffsetAccount',
        'default_offset_subaccount' => 'defaultOffsetSubaccount',
        'reclasification_account' => 'reclasificationAccount',
        'business_account' => 'businessAccount',
        'description' => 'description',
        'use_for_payments_reclasification' => 'useForPaymentsReclasification',
        'reclasification_account_override' => 'reclasificationAccountOverride',
        'offset_account_override' => 'offsetAccountOverride',
        'offset_subaccount_override' => 'offsetSubaccountOverride',
        'offset_account_branch' => 'offsetAccountBranch',
        'vat_zone' => 'vatZone',
        'tax_calculation_mode' => 'taxCalculationMode',
        'last_modified_date_time' => 'lastModifiedDateTime'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'entry_type_id' => 'setEntryTypeId',
        'disable_receipt' => 'setDisableReceipt',
        'module' => 'setModule',
        'default_offset_account_branch' => 'setDefaultOffsetAccountBranch',
        'default_offset_account' => 'setDefaultOffsetAccount',
        'default_offset_subaccount' => 'setDefaultOffsetSubaccount',
        'reclasification_account' => 'setReclasificationAccount',
        'business_account' => 'setBusinessAccount',
        'description' => 'setDescription',
        'use_for_payments_reclasification' => 'setUseForPaymentsReclasification',
        'reclasification_account_override' => 'setReclasificationAccountOverride',
        'offset_account_override' => 'setOffsetAccountOverride',
        'offset_subaccount_override' => 'setOffsetSubaccountOverride',
        'offset_account_branch' => 'setOffsetAccountBranch',
        'vat_zone' => 'setVatZone',
        'tax_calculation_mode' => 'setTaxCalculationMode',
        'last_modified_date_time' => 'setLastModifiedDateTime'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'entry_type_id' => 'getEntryTypeId',
        'disable_receipt' => 'getDisableReceipt',
        'module' => 'getModule',
        'default_offset_account_branch' => 'getDefaultOffsetAccountBranch',
        'default_offset_account' => 'getDefaultOffsetAccount',
        'default_offset_subaccount' => 'getDefaultOffsetSubaccount',
        'reclasification_account' => 'getReclasificationAccount',
        'business_account' => 'getBusinessAccount',
        'description' => 'getDescription',
        'use_for_payments_reclasification' => 'getUseForPaymentsReclasification',
        'reclasification_account_override' => 'getReclasificationAccountOverride',
        'offset_account_override' => 'getOffsetAccountOverride',
        'offset_subaccount_override' => 'getOffsetSubaccountOverride',
        'offset_account_branch' => 'getOffsetAccountBranch',
        'vat_zone' => 'getVatZone',
        'tax_calculation_mode' => 'getTaxCalculationMode',
        'last_modified_date_time' => 'getLastModifiedDateTime'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DISABLE_RECEIPT_DISBURSEMENT = 'Disbursement';
    const DISABLE_RECEIPT_RECEIPT = 'Receipt';
    const TAX_CALCULATION_MODE_TAX_SETTING = 'TaxSetting';
    const TAX_CALCULATION_MODE_GROSS = 'Gross';
    const TAX_CALCULATION_MODE_NET = 'Net';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDisableReceiptAllowableValues()
    {
        return [
            self::DISABLE_RECEIPT_DISBURSEMENT,
            self::DISABLE_RECEIPT_RECEIPT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTaxCalculationModeAllowableValues()
    {
        return [
            self::TAX_CALCULATION_MODE_TAX_SETTING,
            self::TAX_CALCULATION_MODE_GROSS,
            self::TAX_CALCULATION_MODE_NET,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['entry_type_id'] = isset($data['entry_type_id']) ? $data['entry_type_id'] : null;
        $this->container['disable_receipt'] = isset($data['disable_receipt']) ? $data['disable_receipt'] : null;
        $this->container['module'] = isset($data['module']) ? $data['module'] : null;
        $this->container['default_offset_account_branch'] = isset($data['default_offset_account_branch']) ? $data['default_offset_account_branch'] : null;
        $this->container['default_offset_account'] = isset($data['default_offset_account']) ? $data['default_offset_account'] : null;
        $this->container['default_offset_subaccount'] = isset($data['default_offset_subaccount']) ? $data['default_offset_subaccount'] : null;
        $this->container['reclasification_account'] = isset($data['reclasification_account']) ? $data['reclasification_account'] : null;
        $this->container['business_account'] = isset($data['business_account']) ? $data['business_account'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['use_for_payments_reclasification'] = isset($data['use_for_payments_reclasification']) ? $data['use_for_payments_reclasification'] : null;
        $this->container['reclasification_account_override'] = isset($data['reclasification_account_override']) ? $data['reclasification_account_override'] : null;
        $this->container['offset_account_override'] = isset($data['offset_account_override']) ? $data['offset_account_override'] : null;
        $this->container['offset_subaccount_override'] = isset($data['offset_subaccount_override']) ? $data['offset_subaccount_override'] : null;
        $this->container['offset_account_branch'] = isset($data['offset_account_branch']) ? $data['offset_account_branch'] : null;
        $this->container['vat_zone'] = isset($data['vat_zone']) ? $data['vat_zone'] : null;
        $this->container['tax_calculation_mode'] = isset($data['tax_calculation_mode']) ? $data['tax_calculation_mode'] : null;
        $this->container['last_modified_date_time'] = isset($data['last_modified_date_time']) ? $data['last_modified_date_time'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDisableReceiptAllowableValues();
        if (!is_null($this->container['disable_receipt']) && !in_array($this->container['disable_receipt'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'disable_receipt', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTaxCalculationModeAllowableValues();
        if (!is_null($this->container['tax_calculation_mode']) && !in_array($this->container['tax_calculation_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'tax_calculation_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets entry_type_id
     *
     * @return string
     */
    public function getEntryTypeId()
    {
        return $this->container['entry_type_id'];
    }

    /**
     * Sets entry_type_id
     *
     * @param string $entry_type_id Entry type ID* &gt; The entry type, selected by its identifier.
     *
     * @return $this
     */
    public function setEntryTypeId($entry_type_id)
    {
        $this->container['entry_type_id'] = $entry_type_id;

        return $this;
    }

    /**
     * Gets disable_receipt
     *
     * @return string
     */
    public function getDisableReceipt()
    {
        return $this->container['disable_receipt'];
    }

    /**
     * Sets disable_receipt
     *
     * @param string $disable_receipt Disb/receipt &gt; The basic type of cash transaction designated by this entry type: Receipt or Disbursement.
     *
     * @return $this
     */
    public function setDisableReceipt($disable_receipt)
    {
        $allowedValues = $this->getDisableReceiptAllowableValues();
        if (!is_null($disable_receipt) && !in_array($disable_receipt, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'disable_receipt', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['disable_receipt'] = $disable_receipt;

        return $this;
    }

    /**
     * Gets module
     *
     * @return string
     */
    public function getModule()
    {
        return $this->container['module'];
    }

    /**
     * Sets module
     *
     * @param string $module Module &gt; The way the entry type is used in the system.
     *
     * @return $this
     */
    public function setModule($module)
    {
        $this->container['module'] = $module;

        return $this;
    }

    /**
     * Gets default_offset_account_branch
     *
     * @return object
     */
    public function getDefaultOffsetAccountBranch()
    {
        return $this->container['default_offset_account_branch'];
    }

    /**
     * Sets default_offset_account_branch
     *
     * @param object $default_offset_account_branch The branch to which the default offset account belongs.
     *
     * @return $this
     */
    public function setDefaultOffsetAccountBranch($default_offset_account_branch)
    {
        $this->container['default_offset_account_branch'] = $default_offset_account_branch;

        return $this;
    }

    /**
     * Gets default_offset_account
     *
     * @return object
     */
    public function getDefaultOffsetAccount()
    {
        return $this->container['default_offset_account'];
    }

    /**
     * Sets default_offset_account
     *
     * @param object $default_offset_account Default offset account &gt; The account that is used by default as the offset account for this entry type.
     *
     * @return $this
     */
    public function setDefaultOffsetAccount($default_offset_account)
    {
        $this->container['default_offset_account'] = $default_offset_account;

        return $this;
    }

    /**
     * Gets default_offset_subaccount
     *
     * @return object
     */
    public function getDefaultOffsetSubaccount()
    {
        return $this->container['default_offset_subaccount'];
    }

    /**
     * Sets default_offset_subaccount
     *
     * @param object $default_offset_subaccount Default offset subaccount &gt; The corresponding subaccount.
     *
     * @return $this
     */
    public function setDefaultOffsetSubaccount($default_offset_subaccount)
    {
        $this->container['default_offset_subaccount'] = $default_offset_subaccount;

        return $this;
    }

    /**
     * Gets reclasification_account
     *
     * @return object
     */
    public function getReclasificationAccount()
    {
        return $this->container['reclasification_account'];
    }

    /**
     * Sets reclasification_account
     *
     * @param object $reclasification_account Reclassification account &gt;  &gt; The cash account that is used to temporary hold payments that came to the bank account but cannot be entered as valid payments because the customer or supplier is unknown.  The parameter is used together with the Use for payments reclassification check box.
     *
     * @return $this
     */
    public function setReclasificationAccount($reclasification_account)
    {
        $this->container['reclasification_account'] = $reclasification_account;

        return $this;
    }

    /**
     * Gets business_account
     *
     * @return object
     */
    public function getBusinessAccount()
    {
        return $this->container['business_account'];
    }

    /**
     * Sets business_account
     *
     * @param object $business_account Business account &gt; The supplier account, if the entry type is used to record transactions that involve a particular supplier, or the customer account,  if the entry type is used to record transactions that involve a particular customer.
     *
     * @return $this
     */
    public function setBusinessAccount($business_account)
    {
        $this->container['business_account'] = $business_account;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Description &gt; A detailed description of the entry type that is used as transaction description by default.
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets use_for_payments_reclasification
     *
     * @return bool
     */
    public function getUseForPaymentsReclasification()
    {
        return $this->container['use_for_payments_reclasification'];
    }

    /**
     * Sets use_for_payments_reclasification
     *
     * @param bool $use_for_payments_reclasification A check box that you select if this entry type is used to record unknown payments that need to be reclassified later.
     *
     * @return $this
     */
    public function setUseForPaymentsReclasification($use_for_payments_reclasification)
    {
        $this->container['use_for_payments_reclasification'] = $use_for_payments_reclasification;

        return $this;
    }

    /**
     * Gets reclasification_account_override
     *
     * @return object
     */
    public function getReclasificationAccountOverride()
    {
        return $this->container['reclasification_account_override'];
    }

    /**
     * Sets reclasification_account_override
     *
     * @param object $reclasification_account_override The account that should be used instead of the reclassification account specified as the default one on the Entry types tab.
     *
     * @return $this
     */
    public function setReclasificationAccountOverride($reclasification_account_override)
    {
        $this->container['reclasification_account_override'] = $reclasification_account_override;

        return $this;
    }

    /**
     * Gets offset_account_override
     *
     * @return object
     */
    public function getOffsetAccountOverride()
    {
        return $this->container['offset_account_override'];
    }

    /**
     * Sets offset_account_override
     *
     * @param object $offset_account_override Reclassification account override &gt; The account that should be used as the offset account for this entry type with this cash account instead of the default offset account specified on the Entry types tab.   We recommend that for the disbursement type of transaction, you specify an expense account. For the receipt type of transaction, specify an asset account.
     *
     * @return $this
     */
    public function setOffsetAccountOverride($offset_account_override)
    {
        $this->container['offset_account_override'] = $offset_account_override;

        return $this;
    }

    /**
     * Gets offset_subaccount_override
     *
     * @return object
     */
    public function getOffsetSubaccountOverride()
    {
        return $this->container['offset_subaccount_override'];
    }

    /**
     * Sets offset_subaccount_override
     *
     * @param object $offset_subaccount_override Offset account override &gt; The subaccount for this entry type to be used with this cash account instead of the default offset subaccount specified in the Entry types window.
     *
     * @return $this
     */
    public function setOffsetSubaccountOverride($offset_subaccount_override)
    {
        $this->container['offset_subaccount_override'] = $offset_subaccount_override;

        return $this;
    }

    /**
     * Gets offset_account_branch
     *
     * @return object
     */
    public function getOffsetAccountBranch()
    {
        return $this->container['offset_account_branch'];
    }

    /**
     * Sets offset_account_branch
     *
     * @param object $offset_account_branch Default offset account branch &gt; The branch to which the overriding offset account belongs.
     *
     * @return $this
     */
    public function setOffsetAccountBranch($offset_account_branch)
    {
        $this->container['offset_account_branch'] = $offset_account_branch;

        return $this;
    }

    /**
     * Gets vat_zone
     *
     * @return object
     */
    public function getVatZone()
    {
        return $this->container['vat_zone'];
    }

    /**
     * Sets vat_zone
     *
     * @param object $vat_zone VAT zone &gt; The VAT zone to be used by default with this entry type.
     *
     * @return $this
     */
    public function setVatZone($vat_zone)
    {
        $this->container['vat_zone'] = $vat_zone;

        return $this;
    }

    /**
     * Gets tax_calculation_mode
     *
     * @return string
     */
    public function getTaxCalculationMode()
    {
        return $this->container['tax_calculation_mode'];
    }

    /**
     * Sets tax_calculation_mode
     *
     * @param string $tax_calculation_mode Tax calculation mode &gt; The tax calculation mode to be used by default with this entry type
     *
     * @return $this
     */
    public function setTaxCalculationMode($tax_calculation_mode)
    {
        $allowedValues = $this->getTaxCalculationModeAllowableValues();
        if (!is_null($tax_calculation_mode) && !in_array($tax_calculation_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'tax_calculation_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tax_calculation_mode'] = $tax_calculation_mode;

        return $this;
    }

    /**
     * Gets last_modified_date_time
     *
     * @return \DateTime
     */
    public function getLastModifiedDateTime()
    {
        return $this->container['last_modified_date_time'];
    }

    /**
     * Sets last_modified_date_time
     *
     * @param \DateTime $last_modified_date_time last_modified_date_time
     *
     * @return $this
     */
    public function setLastModifiedDateTime($last_modified_date_time)
    {
        $this->container['last_modified_date_time'] = $last_modified_date_time;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


