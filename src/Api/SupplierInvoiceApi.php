<?php
/**
 * SupplierInvoiceApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * SupplierInvoiceApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SupplierInvoiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/documentType/{documentType}/{invoiceNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumber
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumber($invoice_number)
    {
        list($response) = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsync
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsync($invoice_number)
    {
        return $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{invoiceNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber($document_type, $invoice_number, $line_number)
    {
        list($response) = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo($document_type, $invoice_number, $line_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo($document_type, $invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsync($document_type, $invoice_number, $line_number)
    {
        return $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo($document_type, $invoice_number, $line_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo($document_type, $invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }
        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/documentType/{documentType}/{invoiceNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber($invoice_number, $line_number)
    {
        list($response) = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync($invoice_number, $line_number)
    {
        return $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }
        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{invoiceNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumber
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsync
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumber
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoiceDeleteByinvoiceNumber($invoice_number)
    {
        list($response) = $this->supplierInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberAsync
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteByinvoiceNumberAsync($invoice_number)
    {
        return $this->supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDeleteByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceDeleteByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetAllInvoices
     *
     * Get a range of Invoices - ScreenId=AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  bool $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  string $document_type By type of document. (optional)
     * @param  int $released The date when the document was released. (optional)
     * @param  string $project Filter by the project with which the document is associated. (optional)
     * @param  bool $expand_approval Set to true to include approval information. (optional)
     * @param  bool $expand_note Set to true to include description. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto[]
     */
    public function supplierInvoiceGetAllInvoices($expand_attachment = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->supplierInvoiceGetAllInvoicesWithHttpInfo($expand_attachment, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesWithHttpInfo
     *
     * Get a range of Invoices - ScreenId=AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  bool $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  string $document_type By type of document. (optional)
     * @param  int $released The date when the document was released. (optional)
     * @param  string $project Filter by the project with which the document is associated. (optional)
     * @param  bool $expand_approval Set to true to include approval information. (optional)
     * @param  bool $expand_note Set to true to include description. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetAllInvoicesWithHttpInfo($expand_attachment = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto[]';
        $request = $this->supplierInvoiceGetAllInvoicesRequest($expand_attachment, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesAsync
     *
     * Get a range of Invoices - ScreenId=AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  bool $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  string $document_type By type of document. (optional)
     * @param  int $released The date when the document was released. (optional)
     * @param  string $project Filter by the project with which the document is associated. (optional)
     * @param  bool $expand_approval Set to true to include approval information. (optional)
     * @param  bool $expand_note Set to true to include description. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetAllInvoicesAsync($expand_attachment = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        return $this->supplierInvoiceGetAllInvoicesAsyncWithHttpInfo($expand_attachment, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesAsyncWithHttpInfo
     *
     * Get a range of Invoices - ScreenId=AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  bool $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  string $document_type By type of document. (optional)
     * @param  int $released The date when the document was released. (optional)
     * @param  string $project Filter by the project with which the document is associated. (optional)
     * @param  bool $expand_approval Set to true to include approval information. (optional)
     * @param  bool $expand_note Set to true to include description. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetAllInvoicesAsyncWithHttpInfo($expand_attachment = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto[]';
        $request = $this->supplierInvoiceGetAllInvoicesRequest($expand_attachment, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetAllInvoices'
     *
     * @param  bool $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  string $document_type By type of document. (optional)
     * @param  int $released The date when the document was released. (optional)
     * @param  string $project Filter by the project with which the document is associated. (optional)
     * @param  bool $expand_approval Set to true to include approval information. (optional)
     * @param  bool $expand_note Set to true to include description. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceGetAllInvoicesRequest($expand_attachment = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v1/supplierInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($expand_attachment !== null) {
            $queryParams['expandAttachment'] = ObjectSerializer::toQueryValue($expand_attachment);
        }
        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($released !== null) {
            $queryParams['released'] = ObjectSerializer::toQueryValue($released);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($expand_approval !== null) {
            $queryParams['expandApproval'] = ObjectSerializer::toQueryValue($expand_approval);
        }
        // query params
        if ($expand_note !== null) {
            $queryParams['expandNote'] = ObjectSerializer::toQueryValue($expand_note);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($created_date_time !== null) {
            $queryParams['createdDateTime'] = ObjectSerializer::toQueryValue($created_date_time);
        }
        // query params
        if ($created_date_time_condition !== null) {
            $queryParams['createdDateTimeCondition'] = ObjectSerializer::toQueryValue($created_date_time_condition);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentId
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto
     */
    public function supplierInvoiceGetByApprovalDocumentId($system_id)
    {
        list($response) = $this->supplierInvoiceGetByApprovalDocumentIdWithHttpInfo($system_id);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdWithHttpInfo
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByApprovalDocumentIdWithHttpInfo($system_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByApprovalDocumentIdRequest($system_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdAsync
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByApprovalDocumentIdAsync($system_id)
    {
        return $this->supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo($system_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo($system_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByApprovalDocumentIdRequest($system_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByApprovalDocumentId'
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceGetByApprovalDocumentIdRequest($system_id)
    {
        // verify the required parameter 'system_id' is set
        if ($system_id === null || (is_array($system_id) && count($system_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $system_id when calling supplierInvoiceGetByApprovalDocumentId'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/approval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($system_id !== null) {
            $queryParams['systemId'] = ObjectSerializer::toQueryValue($system_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber
     *
     * Get a specific Invoice
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Get a specific Invoice
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumber
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto
     */
    public function supplierInvoiceGetByinvoiceNumber($invoice_number)
    {
        list($response) = $this->supplierInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\SupplierInvoiceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberAsync
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByinvoiceNumberAsync($invoice_number)
    {
        return $this->supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceGetByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceGetByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePost
     *
     * Create an SupplierInvoice
     *
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the SupplierInvoice to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoicePost($supplier_invoice)
    {
        list($response) = $this->supplierInvoicePostWithHttpInfo($supplier_invoice);
        return $response;
    }

    /**
     * Operation supplierInvoicePostWithHttpInfo
     *
     * Create an SupplierInvoice
     *
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the SupplierInvoice to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePostWithHttpInfo($supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePostRequest($supplier_invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePostAsync
     *
     * Create an SupplierInvoice
     *
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the SupplierInvoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePostAsync($supplier_invoice)
    {
        return $this->supplierInvoicePostAsyncWithHttpInfo($supplier_invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePostAsyncWithHttpInfo
     *
     * Create an SupplierInvoice
     *
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the SupplierInvoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePostAsyncWithHttpInfo($supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePostRequest($supplier_invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePost'
     *
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the SupplierInvoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoicePostRequest($supplier_invoice)
    {
        // verify the required parameter 'supplier_invoice' is set
        if ($supplier_invoice === null || (is_array($supplier_invoice) && count($supplier_invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice when calling supplierInvoicePost'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($supplier_invoice)) {
            $_tempBody = $supplier_invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\PrebookSupplierInvoiceActionResultDto
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\PrebookSupplierInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PrebookSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\PrebookSupplierInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PrebookSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/prebook';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber($document_type, $supplier_invoice_number, $supplier_invoice)
    {
        list($response) = $this->supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberWithHttpInfo($document_type, $supplier_invoice_number, $supplier_invoice);
        return $response;
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberWithHttpInfo($document_type, $supplier_invoice_number, $supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberRequest($document_type, $supplier_invoice_number, $supplier_invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberAsync
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberAsync($document_type, $supplier_invoice_number, $supplier_invoice)
    {
        return $this->supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberAsyncWithHttpInfo($document_type, $supplier_invoice_number, $supplier_invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberAsyncWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberAsyncWithHttpInfo($document_type, $supplier_invoice_number, $supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberRequest($document_type, $supplier_invoice_number, $supplier_invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber'
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumberRequest($document_type, $supplier_invoice_number, $supplier_invoice)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber'
            );
        }
        // verify the required parameter 'supplier_invoice_number' is set
        if ($supplier_invoice_number === null || (is_array($supplier_invoice_number) && count($supplier_invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_number when calling supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber'
            );
        }
        // verify the required parameter 'supplier_invoice' is set
        if ($supplier_invoice === null || (is_array($supplier_invoice) && count($supplier_invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice when calling supplierInvoicePutByTypeBydocumentTypesupplierInvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{supplierInvoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($supplier_invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceNumber' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($supplier_invoice)) {
            $_tempBody = $supplier_invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePutBysupplierInvoiceNumber
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function supplierInvoicePutBysupplierInvoiceNumber($supplier_invoice_number, $supplier_invoice)
    {
        list($response) = $this->supplierInvoicePutBysupplierInvoiceNumberWithHttpInfo($supplier_invoice_number, $supplier_invoice);
        return $response;
    }

    /**
     * Operation supplierInvoicePutBysupplierInvoiceNumberWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePutBysupplierInvoiceNumberWithHttpInfo($supplier_invoice_number, $supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePutBysupplierInvoiceNumberRequest($supplier_invoice_number, $supplier_invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePutBysupplierInvoiceNumberAsync
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutBysupplierInvoiceNumberAsync($supplier_invoice_number, $supplier_invoice)
    {
        return $this->supplierInvoicePutBysupplierInvoiceNumberAsyncWithHttpInfo($supplier_invoice_number, $supplier_invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePutBysupplierInvoiceNumberAsyncWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutBysupplierInvoiceNumberAsyncWithHttpInfo($supplier_invoice_number, $supplier_invoice)
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePutBysupplierInvoiceNumberRequest($supplier_invoice_number, $supplier_invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePutBysupplierInvoiceNumber'
     *
     * @param  string $supplier_invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\SupplierInvoiceUpdateDto $supplier_invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoicePutBysupplierInvoiceNumberRequest($supplier_invoice_number, $supplier_invoice)
    {
        // verify the required parameter 'supplier_invoice_number' is set
        if ($supplier_invoice_number === null || (is_array($supplier_invoice_number) && count($supplier_invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_number when calling supplierInvoicePutBysupplierInvoiceNumber'
            );
        }
        // verify the required parameter 'supplier_invoice' is set
        if ($supplier_invoice === null || (is_array($supplier_invoice) && count($supplier_invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice when calling supplierInvoicePutBysupplierInvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{supplierInvoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($supplier_invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'supplierInvoiceNumber' . '}',
                ObjectSerializer::toPathValue($supplier_invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($supplier_invoice)) {
            $_tempBody = $supplier_invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumber
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumber($invoice_number)
    {
        list($response) = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberAsync
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberAsync($invoice_number)
    {
        return $this->supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceReleaseInvoiceByinvoiceNumber'
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceReleaseInvoiceByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{invoiceNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\VoidSupplierInvoiceActionResultDto
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number)
    {
        list($response) = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number);
        return $response;
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\VoidSupplierInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\VoidSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\VoidSupplierInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number)
    {
        return $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\VoidSupplierInvoiceActionResultDto';
        $request = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number)
    {
        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/voidinvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
