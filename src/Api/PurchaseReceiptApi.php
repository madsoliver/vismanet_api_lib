<?php
/**
 * PurchaseReceiptApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * PurchaseReceiptApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PurchaseReceiptApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrderLinesByreceiptNumber
     *
     * Add purchase order lines to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderLinesListUpdateDto $purchase_order_lines_list Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\AddOrderLinesToPurchaseReceiptActionResultDto
     */
    public function purchaseReceiptAddPurchaseOrderLinesByreceiptNumber($receipt_number, $purchase_order_lines_list)
    {
        list($response) = $this->purchaseReceiptAddPurchaseOrderLinesByreceiptNumberWithHttpInfo($receipt_number, $purchase_order_lines_list);
        return $response;
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrderLinesByreceiptNumberWithHttpInfo
     *
     * Add purchase order lines to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderLinesListUpdateDto $purchase_order_lines_list Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\AddOrderLinesToPurchaseReceiptActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptAddPurchaseOrderLinesByreceiptNumberWithHttpInfo($receipt_number, $purchase_order_lines_list)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\AddOrderLinesToPurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptAddPurchaseOrderLinesByreceiptNumberRequest($receipt_number, $purchase_order_lines_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\AddOrderLinesToPurchaseReceiptActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrderLinesByreceiptNumberAsync
     *
     * Add purchase order lines to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderLinesListUpdateDto $purchase_order_lines_list Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptAddPurchaseOrderLinesByreceiptNumberAsync($receipt_number, $purchase_order_lines_list)
    {
        return $this->purchaseReceiptAddPurchaseOrderLinesByreceiptNumberAsyncWithHttpInfo($receipt_number, $purchase_order_lines_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrderLinesByreceiptNumberAsyncWithHttpInfo
     *
     * Add purchase order lines to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderLinesListUpdateDto $purchase_order_lines_list Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptAddPurchaseOrderLinesByreceiptNumberAsyncWithHttpInfo($receipt_number, $purchase_order_lines_list)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\AddOrderLinesToPurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptAddPurchaseOrderLinesByreceiptNumberRequest($receipt_number, $purchase_order_lines_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptAddPurchaseOrderLinesByreceiptNumber'
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderLinesListUpdateDto $purchase_order_lines_list Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptAddPurchaseOrderLinesByreceiptNumberRequest($receipt_number, $purchase_order_lines_list)
    {
        // verify the required parameter 'receipt_number' is set
        if ($receipt_number === null || (is_array($receipt_number) && count($receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_number when calling purchaseReceiptAddPurchaseOrderLinesByreceiptNumber'
            );
        }
        // verify the required parameter 'purchase_order_lines_list' is set
        if ($purchase_order_lines_list === null || (is_array($purchase_order_lines_list) && count($purchase_order_lines_list) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchase_order_lines_list when calling purchaseReceiptAddPurchaseOrderLinesByreceiptNumber'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{receiptNumber}/action/addpurchaseorderlines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($purchase_order_lines_list)) {
            $_tempBody = $purchase_order_lines_list;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrdersByreceiptNumber
     *
     * Add purchase orders to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderListUpdateDto $purchase_orders Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\AddOrdersToPurchaseReceiptActionResultDto
     */
    public function purchaseReceiptAddPurchaseOrdersByreceiptNumber($receipt_number, $purchase_orders)
    {
        list($response) = $this->purchaseReceiptAddPurchaseOrdersByreceiptNumberWithHttpInfo($receipt_number, $purchase_orders);
        return $response;
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrdersByreceiptNumberWithHttpInfo
     *
     * Add purchase orders to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderListUpdateDto $purchase_orders Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\AddOrdersToPurchaseReceiptActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptAddPurchaseOrdersByreceiptNumberWithHttpInfo($receipt_number, $purchase_orders)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\AddOrdersToPurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptAddPurchaseOrdersByreceiptNumberRequest($receipt_number, $purchase_orders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\AddOrdersToPurchaseReceiptActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrdersByreceiptNumberAsync
     *
     * Add purchase orders to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderListUpdateDto $purchase_orders Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptAddPurchaseOrdersByreceiptNumberAsync($receipt_number, $purchase_orders)
    {
        return $this->purchaseReceiptAddPurchaseOrdersByreceiptNumberAsyncWithHttpInfo($receipt_number, $purchase_orders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptAddPurchaseOrdersByreceiptNumberAsyncWithHttpInfo
     *
     * Add purchase orders to receipt
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderListUpdateDto $purchase_orders Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptAddPurchaseOrdersByreceiptNumberAsyncWithHttpInfo($receipt_number, $purchase_orders)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\AddOrdersToPurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptAddPurchaseOrdersByreceiptNumberRequest($receipt_number, $purchase_orders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptAddPurchaseOrdersByreceiptNumber'
     *
     * @param  string $receipt_number Reference number of the receipt to which to add the orders (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptOrderListUpdateDto $purchase_orders Object containing an array of reference numbers of the orders to be added to the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptAddPurchaseOrdersByreceiptNumberRequest($receipt_number, $purchase_orders)
    {
        // verify the required parameter 'receipt_number' is set
        if ($receipt_number === null || (is_array($receipt_number) && count($receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_number when calling purchaseReceiptAddPurchaseOrdersByreceiptNumber'
            );
        }
        // verify the required parameter 'purchase_orders' is set
        if ($purchase_orders === null || (is_array($purchase_orders) && count($purchase_orders) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchase_orders when calling purchaseReceiptAddPurchaseOrdersByreceiptNumber'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{receiptNumber}/action/addpurchaseorder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($purchase_orders)) {
            $_tempBody = $purchase_orders;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptGetAllReceiptBasic
     *
     * Get a range of Purchase Receipts - ScreenId=PO302000  Please use a page size lower or equal to the allowed max page size which is 500
     *
     * @param  string $receipt_type receipt_type (optional)
     * @param  string $status status (optional)
     * @param  string $greater_than_value greater_than_value (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $last_modified_date_time last_modified_date_time (optional)
     * @param  string $last_modified_date_time_condition last_modified_date_time_condition (optional)
     * @param  string $supplier supplier (optional)
     * @param  string $po_order_nbr po_order_nbr (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\PurchaseReceiptDto[]
     */
    public function purchaseReceiptGetAllReceiptBasic($receipt_type = null, $status = null, $greater_than_value = null, $number_to_read = null, $skip_records = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $supplier = null, $po_order_nbr = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->purchaseReceiptGetAllReceiptBasicWithHttpInfo($receipt_type, $status, $greater_than_value, $number_to_read, $skip_records, $last_modified_date_time, $last_modified_date_time_condition, $supplier, $po_order_nbr, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation purchaseReceiptGetAllReceiptBasicWithHttpInfo
     *
     * Get a range of Purchase Receipts - ScreenId=PO302000  Please use a page size lower or equal to the allowed max page size which is 500
     *
     * @param  string $receipt_type (optional)
     * @param  string $status (optional)
     * @param  string $greater_than_value (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $last_modified_date_time (optional)
     * @param  string $last_modified_date_time_condition (optional)
     * @param  string $supplier (optional)
     * @param  string $po_order_nbr (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\PurchaseReceiptDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptGetAllReceiptBasicWithHttpInfo($receipt_type = null, $status = null, $greater_than_value = null, $number_to_read = null, $skip_records = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $supplier = null, $po_order_nbr = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto[]';
        $request = $this->purchaseReceiptGetAllReceiptBasicRequest($receipt_type, $status, $greater_than_value, $number_to_read, $skip_records, $last_modified_date_time, $last_modified_date_time_condition, $supplier, $po_order_nbr, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptGetAllReceiptBasicAsync
     *
     * Get a range of Purchase Receipts - ScreenId=PO302000  Please use a page size lower or equal to the allowed max page size which is 500
     *
     * @param  string $receipt_type (optional)
     * @param  string $status (optional)
     * @param  string $greater_than_value (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $last_modified_date_time (optional)
     * @param  string $last_modified_date_time_condition (optional)
     * @param  string $supplier (optional)
     * @param  string $po_order_nbr (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptGetAllReceiptBasicAsync($receipt_type = null, $status = null, $greater_than_value = null, $number_to_read = null, $skip_records = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $supplier = null, $po_order_nbr = null, $page_number = null, $page_size = null)
    {
        return $this->purchaseReceiptGetAllReceiptBasicAsyncWithHttpInfo($receipt_type, $status, $greater_than_value, $number_to_read, $skip_records, $last_modified_date_time, $last_modified_date_time_condition, $supplier, $po_order_nbr, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptGetAllReceiptBasicAsyncWithHttpInfo
     *
     * Get a range of Purchase Receipts - ScreenId=PO302000  Please use a page size lower or equal to the allowed max page size which is 500
     *
     * @param  string $receipt_type (optional)
     * @param  string $status (optional)
     * @param  string $greater_than_value (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $last_modified_date_time (optional)
     * @param  string $last_modified_date_time_condition (optional)
     * @param  string $supplier (optional)
     * @param  string $po_order_nbr (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptGetAllReceiptBasicAsyncWithHttpInfo($receipt_type = null, $status = null, $greater_than_value = null, $number_to_read = null, $skip_records = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $supplier = null, $po_order_nbr = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto[]';
        $request = $this->purchaseReceiptGetAllReceiptBasicRequest($receipt_type, $status, $greater_than_value, $number_to_read, $skip_records, $last_modified_date_time, $last_modified_date_time_condition, $supplier, $po_order_nbr, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptGetAllReceiptBasic'
     *
     * @param  string $receipt_type (optional)
     * @param  string $status (optional)
     * @param  string $greater_than_value (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $last_modified_date_time (optional)
     * @param  string $last_modified_date_time_condition (optional)
     * @param  string $supplier (optional)
     * @param  string $po_order_nbr (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptGetAllReceiptBasicRequest($receipt_type = null, $status = null, $greater_than_value = null, $number_to_read = null, $skip_records = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $supplier = null, $po_order_nbr = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v1/PurchaseReceipt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($receipt_type !== null) {
            $queryParams['receiptType'] = ObjectSerializer::toQueryValue($receipt_type);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($supplier !== null) {
            $queryParams['supplier'] = ObjectSerializer::toQueryValue($supplier);
        }
        // query params
        if ($po_order_nbr !== null) {
            $queryParams['poOrderNbr'] = ObjectSerializer::toQueryValue($po_order_nbr);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptGetPurchaseReceiptBasicByreceiptNbr
     *
     * Get a specific Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the Purchase Receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\PurchaseReceiptDto
     */
    public function purchaseReceiptGetPurchaseReceiptBasicByreceiptNbr($receipt_nbr)
    {
        list($response) = $this->purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrWithHttpInfo($receipt_nbr);
        return $response;
    }

    /**
     * Operation purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrWithHttpInfo
     *
     * Get a specific Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the Purchase Receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\PurchaseReceiptDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrWithHttpInfo($receipt_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto';
        $request = $this->purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrRequest($receipt_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrAsync
     *
     * Get a specific Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the Purchase Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrAsync($receipt_nbr)
    {
        return $this->purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrAsyncWithHttpInfo
     *
     * Get a specific Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the Purchase Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PurchaseReceiptDto';
        $request = $this->purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrRequest($receipt_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptGetPurchaseReceiptBasicByreceiptNbr'
     *
     * @param  string $receipt_nbr Identifies the Purchase Receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptGetPurchaseReceiptBasicByreceiptNbrRequest($receipt_nbr)
    {
        // verify the required parameter 'receipt_nbr' is set
        if ($receipt_nbr === null || (is_array($receipt_nbr) && count($receipt_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_nbr when calling purchaseReceiptGetPurchaseReceiptBasicByreceiptNbr'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{receiptNbr}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNbr' . '}',
                ObjectSerializer::toPathValue($receipt_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptPost
     *
     * Create a Purchase Receipt
     *
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function purchaseReceiptPost($po_receipt_update_dto)
    {
        list($response) = $this->purchaseReceiptPostWithHttpInfo($po_receipt_update_dto);
        return $response;
    }

    /**
     * Operation purchaseReceiptPostWithHttpInfo
     *
     * Create a Purchase Receipt
     *
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptPostWithHttpInfo($po_receipt_update_dto)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPostRequest($po_receipt_update_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptPostAsync
     *
     * Create a Purchase Receipt
     *
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPostAsync($po_receipt_update_dto)
    {
        return $this->purchaseReceiptPostAsyncWithHttpInfo($po_receipt_update_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptPostAsyncWithHttpInfo
     *
     * Create a Purchase Receipt
     *
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPostAsyncWithHttpInfo($po_receipt_update_dto)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPostRequest($po_receipt_update_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptPost'
     *
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptPostRequest($po_receipt_update_dto)
    {
        // verify the required parameter 'po_receipt_update_dto' is set
        if ($po_receipt_update_dto === null || (is_array($po_receipt_update_dto) && count($po_receipt_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $po_receipt_update_dto when calling purchaseReceiptPost'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($po_receipt_update_dto)) {
            $_tempBody = $po_receipt_update_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptPrintPurchaseReceiptByreceiptNbr
     *
     * Get the print report of a Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function purchaseReceiptPrintPurchaseReceiptByreceiptNbr($receipt_nbr)
    {
        list($response) = $this->purchaseReceiptPrintPurchaseReceiptByreceiptNbrWithHttpInfo($receipt_nbr);
        return $response;
    }

    /**
     * Operation purchaseReceiptPrintPurchaseReceiptByreceiptNbrWithHttpInfo
     *
     * Get the print report of a Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the receipt (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptPrintPurchaseReceiptByreceiptNbrWithHttpInfo($receipt_nbr)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPrintPurchaseReceiptByreceiptNbrRequest($receipt_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptPrintPurchaseReceiptByreceiptNbrAsync
     *
     * Get the print report of a Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPrintPurchaseReceiptByreceiptNbrAsync($receipt_nbr)
    {
        return $this->purchaseReceiptPrintPurchaseReceiptByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptPrintPurchaseReceiptByreceiptNbrAsyncWithHttpInfo
     *
     * Get the print report of a Purchase Receipt
     *
     * @param  string $receipt_nbr Identifies the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPrintPurchaseReceiptByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPrintPurchaseReceiptByreceiptNbrRequest($receipt_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptPrintPurchaseReceiptByreceiptNbr'
     *
     * @param  string $receipt_nbr Identifies the receipt (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptPrintPurchaseReceiptByreceiptNbrRequest($receipt_nbr)
    {
        // verify the required parameter 'receipt_nbr' is set
        if ($receipt_nbr === null || (is_array($receipt_nbr) && count($receipt_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_nbr when calling purchaseReceiptPrintPurchaseReceiptByreceiptNbr'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{receiptNbr}/print';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNbr' . '}',
                ObjectSerializer::toPathValue($receipt_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptPutBypoReceiptNumber
     *
     * Update a specific Purchase Receipt
     *
     * @param  string $po_receipt_number Identifies the  Purchase Receipt  to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt  to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function purchaseReceiptPutBypoReceiptNumber($po_receipt_number, $po_receipt_update_dto)
    {
        list($response) = $this->purchaseReceiptPutBypoReceiptNumberWithHttpInfo($po_receipt_number, $po_receipt_update_dto);
        return $response;
    }

    /**
     * Operation purchaseReceiptPutBypoReceiptNumberWithHttpInfo
     *
     * Update a specific Purchase Receipt
     *
     * @param  string $po_receipt_number Identifies the  Purchase Receipt  to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt  to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptPutBypoReceiptNumberWithHttpInfo($po_receipt_number, $po_receipt_update_dto)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPutBypoReceiptNumberRequest($po_receipt_number, $po_receipt_update_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptPutBypoReceiptNumberAsync
     *
     * Update a specific Purchase Receipt
     *
     * @param  string $po_receipt_number Identifies the  Purchase Receipt  to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt  to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPutBypoReceiptNumberAsync($po_receipt_number, $po_receipt_update_dto)
    {
        return $this->purchaseReceiptPutBypoReceiptNumberAsyncWithHttpInfo($po_receipt_number, $po_receipt_update_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptPutBypoReceiptNumberAsyncWithHttpInfo
     *
     * Update a specific Purchase Receipt
     *
     * @param  string $po_receipt_number Identifies the  Purchase Receipt  to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt  to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptPutBypoReceiptNumberAsyncWithHttpInfo($po_receipt_number, $po_receipt_update_dto)
    {
        $returnType = 'object';
        $request = $this->purchaseReceiptPutBypoReceiptNumberRequest($po_receipt_number, $po_receipt_update_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptPutBypoReceiptNumber'
     *
     * @param  string $po_receipt_number Identifies the  Purchase Receipt  to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\PurchaseReceiptUpdateDto $po_receipt_update_dto Defines the data for the  Purchase Receipt  to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptPutBypoReceiptNumberRequest($po_receipt_number, $po_receipt_update_dto)
    {
        // verify the required parameter 'po_receipt_number' is set
        if ($po_receipt_number === null || (is_array($po_receipt_number) && count($po_receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $po_receipt_number when calling purchaseReceiptPutBypoReceiptNumber'
            );
        }
        // verify the required parameter 'po_receipt_update_dto' is set
        if ($po_receipt_update_dto === null || (is_array($po_receipt_update_dto) && count($po_receipt_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $po_receipt_update_dto when calling purchaseReceiptPutBypoReceiptNumber'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{poReceiptNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($po_receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'poReceiptNumber' . '}',
                ObjectSerializer::toPathValue($po_receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($po_receipt_update_dto)) {
            $_tempBody = $po_receipt_update_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation purchaseReceiptReleaseInvoiceByreceiptNumber
     *
     * Release purchase receipt operation
     *
     * @param  string $receipt_number Reference number of the receipt to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReleasePurchaseReceiptActionResultDto
     */
    public function purchaseReceiptReleaseInvoiceByreceiptNumber($receipt_number)
    {
        list($response) = $this->purchaseReceiptReleaseInvoiceByreceiptNumberWithHttpInfo($receipt_number);
        return $response;
    }

    /**
     * Operation purchaseReceiptReleaseInvoiceByreceiptNumberWithHttpInfo
     *
     * Release purchase receipt operation
     *
     * @param  string $receipt_number Reference number of the receipt to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReleasePurchaseReceiptActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function purchaseReceiptReleaseInvoiceByreceiptNumberWithHttpInfo($receipt_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleasePurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptReleaseInvoiceByreceiptNumberRequest($receipt_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReleasePurchaseReceiptActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation purchaseReceiptReleaseInvoiceByreceiptNumberAsync
     *
     * Release purchase receipt operation
     *
     * @param  string $receipt_number Reference number of the receipt to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptReleaseInvoiceByreceiptNumberAsync($receipt_number)
    {
        return $this->purchaseReceiptReleaseInvoiceByreceiptNumberAsyncWithHttpInfo($receipt_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation purchaseReceiptReleaseInvoiceByreceiptNumberAsyncWithHttpInfo
     *
     * Release purchase receipt operation
     *
     * @param  string $receipt_number Reference number of the receipt to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function purchaseReceiptReleaseInvoiceByreceiptNumberAsyncWithHttpInfo($receipt_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleasePurchaseReceiptActionResultDto';
        $request = $this->purchaseReceiptReleaseInvoiceByreceiptNumberRequest($receipt_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'purchaseReceiptReleaseInvoiceByreceiptNumber'
     *
     * @param  string $receipt_number Reference number of the receipt to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function purchaseReceiptReleaseInvoiceByreceiptNumberRequest($receipt_number)
    {
        // verify the required parameter 'receipt_number' is set
        if ($receipt_number === null || (is_array($receipt_number) && count($receipt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_number when calling purchaseReceiptReleaseInvoiceByreceiptNumber'
            );
        }

        $resourcePath = '/controller/api/v1/PurchaseReceipt/{receiptNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNumber' . '}',
                ObjectSerializer::toPathValue($receipt_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
