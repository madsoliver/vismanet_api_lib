<?php
/**
 * DimensionApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * DimensionApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DimensionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation dimensionGetDimensionBydimensionId
     *
     * Get a specific Dimension
     *
     * @param  string $dimension_id Identifies the dimension (required)
     * @param  string $greater_than_value Greater-than value. The item which is the object for this, varies from API to API. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords.        /// (optional)
     * @param  string $order_by This field has been deprecated and will be removed in future versions. The OrderBy parameter has no effect on the result. (optional)
     * @param  string $last_modified_date_time System-generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System-retrieved information for state/condition. (optional)
     * @param  bool $expand_segments_values Flag can be used to return data without the segment values. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\DtoDimension
     */
    public function dimensionGetDimensionBydimensionId($dimension_id, $greater_than_value = null, $number_to_read = null, $skip_records = null, $order_by = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $expand_segments_values = null)
    {
        list($response) = $this->dimensionGetDimensionBydimensionIdWithHttpInfo($dimension_id, $greater_than_value, $number_to_read, $skip_records, $order_by, $last_modified_date_time, $last_modified_date_time_condition, $expand_segments_values);
        return $response;
    }

    /**
     * Operation dimensionGetDimensionBydimensionIdWithHttpInfo
     *
     * Get a specific Dimension
     *
     * @param  string $dimension_id Identifies the dimension (required)
     * @param  string $greater_than_value Greater-than value. The item which is the object for this, varies from API to API. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords.        /// (optional)
     * @param  string $order_by This field has been deprecated and will be removed in future versions. The OrderBy parameter has no effect on the result. (optional)
     * @param  string $last_modified_date_time System-generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System-retrieved information for state/condition. (optional)
     * @param  bool $expand_segments_values Flag can be used to return data without the segment values. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\DtoDimension, HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionGetDimensionBydimensionIdWithHttpInfo($dimension_id, $greater_than_value = null, $number_to_read = null, $skip_records = null, $order_by = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $expand_segments_values = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoDimension';
        $request = $this->dimensionGetDimensionBydimensionIdRequest($dimension_id, $greater_than_value, $number_to_read, $skip_records, $order_by, $last_modified_date_time, $last_modified_date_time_condition, $expand_segments_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\DtoDimension',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionGetDimensionBydimensionIdAsync
     *
     * Get a specific Dimension
     *
     * @param  string $dimension_id Identifies the dimension (required)
     * @param  string $greater_than_value Greater-than value. The item which is the object for this, varies from API to API. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords.        /// (optional)
     * @param  string $order_by This field has been deprecated and will be removed in future versions. The OrderBy parameter has no effect on the result. (optional)
     * @param  string $last_modified_date_time System-generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System-retrieved information for state/condition. (optional)
     * @param  bool $expand_segments_values Flag can be used to return data without the segment values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetDimensionBydimensionIdAsync($dimension_id, $greater_than_value = null, $number_to_read = null, $skip_records = null, $order_by = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $expand_segments_values = null)
    {
        return $this->dimensionGetDimensionBydimensionIdAsyncWithHttpInfo($dimension_id, $greater_than_value, $number_to_read, $skip_records, $order_by, $last_modified_date_time, $last_modified_date_time_condition, $expand_segments_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionGetDimensionBydimensionIdAsyncWithHttpInfo
     *
     * Get a specific Dimension
     *
     * @param  string $dimension_id Identifies the dimension (required)
     * @param  string $greater_than_value Greater-than value. The item which is the object for this, varies from API to API. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords.        /// (optional)
     * @param  string $order_by This field has been deprecated and will be removed in future versions. The OrderBy parameter has no effect on the result. (optional)
     * @param  string $last_modified_date_time System-generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System-retrieved information for state/condition. (optional)
     * @param  bool $expand_segments_values Flag can be used to return data without the segment values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetDimensionBydimensionIdAsyncWithHttpInfo($dimension_id, $greater_than_value = null, $number_to_read = null, $skip_records = null, $order_by = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $expand_segments_values = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoDimension';
        $request = $this->dimensionGetDimensionBydimensionIdRequest($dimension_id, $greater_than_value, $number_to_read, $skip_records, $order_by, $last_modified_date_time, $last_modified_date_time_condition, $expand_segments_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionGetDimensionBydimensionId'
     *
     * @param  string $dimension_id Identifies the dimension (required)
     * @param  string $greater_than_value Greater-than value. The item which is the object for this, varies from API to API. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords.        /// (optional)
     * @param  string $order_by This field has been deprecated and will be removed in future versions. The OrderBy parameter has no effect on the result. (optional)
     * @param  string $last_modified_date_time System-generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System-retrieved information for state/condition. (optional)
     * @param  bool $expand_segments_values Flag can be used to return data without the segment values. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionGetDimensionBydimensionIdRequest($dimension_id, $greater_than_value = null, $number_to_read = null, $skip_records = null, $order_by = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $expand_segments_values = null)
    {
        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling dimensionGetDimensionBydimensionId'
            );
        }

        $resourcePath = '/controller/api/v1/dimension/{dimensionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($expand_segments_values !== null) {
            $queryParams['expandSegmentsValues'] = ObjectSerializer::toQueryValue($expand_segments_values);
        }

        // path params
        if ($dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dimensionId' . '}',
                ObjectSerializer::toPathValue($dimension_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dimensionGetDimensionList
     *
     * Get a list of all Dimension names/IDs ScreenId=CS202000
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function dimensionGetDimensionList()
    {
        list($response) = $this->dimensionGetDimensionListWithHttpInfo();
        return $response;
    }

    /**
     * Operation dimensionGetDimensionListWithHttpInfo
     *
     * Get a list of all Dimension names/IDs ScreenId=CS202000
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionGetDimensionListWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->dimensionGetDimensionListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionGetDimensionListAsync
     *
     * Get a list of all Dimension names/IDs ScreenId=CS202000
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetDimensionListAsync()
    {
        return $this->dimensionGetDimensionListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionGetDimensionListAsyncWithHttpInfo
     *
     * Get a list of all Dimension names/IDs ScreenId=CS202000
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetDimensionListAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->dimensionGetDimensionListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionGetDimensionList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionGetDimensionListRequest()
    {

        $resourcePath = '/controller/api/v1/dimension';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dimensionGetSegmentBydimensionIdsegmentId
     *
     * Get a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\DtoSegment
     */
    public function dimensionGetSegmentBydimensionIdsegmentId($dimension_id, $segment_id)
    {
        list($response) = $this->dimensionGetSegmentBydimensionIdsegmentIdWithHttpInfo($dimension_id, $segment_id);
        return $response;
    }

    /**
     * Operation dimensionGetSegmentBydimensionIdsegmentIdWithHttpInfo
     *
     * Get a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\DtoSegment, HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionGetSegmentBydimensionIdsegmentIdWithHttpInfo($dimension_id, $segment_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegment';
        $request = $this->dimensionGetSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\DtoSegment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionGetSegmentBydimensionIdsegmentIdAsync
     *
     * Get a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentBydimensionIdsegmentIdAsync($dimension_id, $segment_id)
    {
        return $this->dimensionGetSegmentBydimensionIdsegmentIdAsyncWithHttpInfo($dimension_id, $segment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionGetSegmentBydimensionIdsegmentIdAsyncWithHttpInfo
     *
     * Get a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentBydimensionIdsegmentIdAsyncWithHttpInfo($dimension_id, $segment_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegment';
        $request = $this->dimensionGetSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionGetSegmentBydimensionIdsegmentId'
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionGetSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id)
    {
        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling dimensionGetSegmentBydimensionIdsegmentId'
            );
        }
        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling dimensionGetSegmentBydimensionIdsegmentId'
            );
        }

        $resourcePath = '/controller/api/v1/dimension/{dimensionId}/{segmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dimensionId' . '}',
                ObjectSerializer::toPathValue($dimension_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdpublicId
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $public_id Identifies the SegmentValue by its publicId (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\DtoSegmentValue
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdpublicId($dimension_id, $segment_id, $public_id)
    {
        list($response) = $this->dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdWithHttpInfo($dimension_id, $segment_id, $public_id);
        return $response;
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdWithHttpInfo
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $public_id Identifies the SegmentValue by its publicId (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\DtoSegmentValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdWithHttpInfo($dimension_id, $segment_id, $public_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegmentValue';
        $request = $this->dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdRequest($dimension_id, $segment_id, $public_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\DtoSegmentValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdAsync
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $public_id Identifies the SegmentValue by its publicId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdAsync($dimension_id, $segment_id, $public_id)
    {
        return $this->dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdAsyncWithHttpInfo($dimension_id, $segment_id, $public_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdAsyncWithHttpInfo
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $public_id Identifies the SegmentValue by its publicId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdAsyncWithHttpInfo($dimension_id, $segment_id, $public_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegmentValue';
        $request = $this->dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdRequest($dimension_id, $segment_id, $public_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionGetSegmentValueBydimensionIdsegmentIdpublicId'
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $public_id Identifies the SegmentValue by its publicId (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionGetSegmentValueBydimensionIdsegmentIdpublicIdRequest($dimension_id, $segment_id, $public_id)
    {
        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdpublicId'
            );
        }
        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdpublicId'
            );
        }
        // verify the required parameter 'public_id' is set
        if ($public_id === null || (is_array($public_id) && count($public_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $public_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdpublicId'
            );
        }

        $resourcePath = '/controller/api/v1/dimension/{dimensionId}/{segmentId}/publicid/{publicId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dimensionId' . '}',
                ObjectSerializer::toPathValue($dimension_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }
        // path params
        if ($public_id !== null) {
            $resourcePath = str_replace(
                '{' . 'publicId' . '}',
                ObjectSerializer::toPathValue($public_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdvalueId
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $value_id Identifies the SegmentValue by Id. Must be Base64 encoded. (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\DtoSegmentValue
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdvalueId($dimension_id, $segment_id, $value_id)
    {
        list($response) = $this->dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdWithHttpInfo($dimension_id, $segment_id, $value_id);
        return $response;
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdWithHttpInfo
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $value_id Identifies the SegmentValue by Id. Must be Base64 encoded. (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\DtoSegmentValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdWithHttpInfo($dimension_id, $segment_id, $value_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegmentValue';
        $request = $this->dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdRequest($dimension_id, $segment_id, $value_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\DtoSegmentValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdAsync
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $value_id Identifies the SegmentValue by Id. Must be Base64 encoded. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdAsync($dimension_id, $segment_id, $value_id)
    {
        return $this->dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdAsyncWithHttpInfo($dimension_id, $segment_id, $value_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdAsyncWithHttpInfo
     *
     * Get a specific SegmentValue for a specific Segment for a specific Dimension
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $value_id Identifies the SegmentValue by Id. Must be Base64 encoded. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdAsyncWithHttpInfo($dimension_id, $segment_id, $value_id)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\DtoSegmentValue';
        $request = $this->dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdRequest($dimension_id, $segment_id, $value_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionGetSegmentValueBydimensionIdsegmentIdvalueId'
     *
     * @param  string $dimension_id Identifies the Dimension (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  string $value_id Identifies the SegmentValue by Id. Must be Base64 encoded. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionGetSegmentValueBydimensionIdsegmentIdvalueIdRequest($dimension_id, $segment_id, $value_id)
    {
        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdvalueId'
            );
        }
        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdvalueId'
            );
        }
        // verify the required parameter 'value_id' is set
        if ($value_id === null || (is_array($value_id) && count($value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value_id when calling dimensionGetSegmentValueBydimensionIdsegmentIdvalueId'
            );
        }

        $resourcePath = '/controller/api/v1/dimension/{dimensionId}/{segmentId}/{valueId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dimensionId' . '}',
                ObjectSerializer::toPathValue($dimension_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }
        // path params
        if ($value_id !== null) {
            $resourcePath = str_replace(
                '{' . 'valueId' . '}',
                ObjectSerializer::toPathValue($value_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dimensionUpdateSegmentBydimensionIdsegmentId
     *
     * Update a Segment
     *
     * @param  string $dimension_id Identifies the Dimension for which the Segment is defined (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  \Ekstralys\VismaNetApi\Model\DtoSegmentUpdateDto $update Defines the data for the Segment to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function dimensionUpdateSegmentBydimensionIdsegmentId($dimension_id, $segment_id, $update)
    {
        list($response) = $this->dimensionUpdateSegmentBydimensionIdsegmentIdWithHttpInfo($dimension_id, $segment_id, $update);
        return $response;
    }

    /**
     * Operation dimensionUpdateSegmentBydimensionIdsegmentIdWithHttpInfo
     *
     * Update a Segment
     *
     * @param  string $dimension_id Identifies the Dimension for which the Segment is defined (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  \Ekstralys\VismaNetApi\Model\DtoSegmentUpdateDto $update Defines the data for the Segment to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function dimensionUpdateSegmentBydimensionIdsegmentIdWithHttpInfo($dimension_id, $segment_id, $update)
    {
        $returnType = 'object';
        $request = $this->dimensionUpdateSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id, $update);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dimensionUpdateSegmentBydimensionIdsegmentIdAsync
     *
     * Update a Segment
     *
     * @param  string $dimension_id Identifies the Dimension for which the Segment is defined (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  \Ekstralys\VismaNetApi\Model\DtoSegmentUpdateDto $update Defines the data for the Segment to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionUpdateSegmentBydimensionIdsegmentIdAsync($dimension_id, $segment_id, $update)
    {
        return $this->dimensionUpdateSegmentBydimensionIdsegmentIdAsyncWithHttpInfo($dimension_id, $segment_id, $update)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dimensionUpdateSegmentBydimensionIdsegmentIdAsyncWithHttpInfo
     *
     * Update a Segment
     *
     * @param  string $dimension_id Identifies the Dimension for which the Segment is defined (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  \Ekstralys\VismaNetApi\Model\DtoSegmentUpdateDto $update Defines the data for the Segment to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dimensionUpdateSegmentBydimensionIdsegmentIdAsyncWithHttpInfo($dimension_id, $segment_id, $update)
    {
        $returnType = 'object';
        $request = $this->dimensionUpdateSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id, $update);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dimensionUpdateSegmentBydimensionIdsegmentId'
     *
     * @param  string $dimension_id Identifies the Dimension for which the Segment is defined (required)
     * @param  int $segment_id Identifies the Segment (required)
     * @param  \Ekstralys\VismaNetApi\Model\DtoSegmentUpdateDto $update Defines the data for the Segment to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dimensionUpdateSegmentBydimensionIdsegmentIdRequest($dimension_id, $segment_id, $update)
    {
        // verify the required parameter 'dimension_id' is set
        if ($dimension_id === null || (is_array($dimension_id) && count($dimension_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dimension_id when calling dimensionUpdateSegmentBydimensionIdsegmentId'
            );
        }
        // verify the required parameter 'segment_id' is set
        if ($segment_id === null || (is_array($segment_id) && count($segment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $segment_id when calling dimensionUpdateSegmentBydimensionIdsegmentId'
            );
        }
        // verify the required parameter 'update' is set
        if ($update === null || (is_array($update) && count($update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update when calling dimensionUpdateSegmentBydimensionIdsegmentId'
            );
        }

        $resourcePath = '/controller/api/v1/dimension/{dimensionId}/{segmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($dimension_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dimensionId' . '}',
                ObjectSerializer::toPathValue($dimension_id),
                $resourcePath
            );
        }
        // path params
        if ($segment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'segmentId' . '}',
                ObjectSerializer::toPathValue($segment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update)) {
            $_tempBody = $update;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
