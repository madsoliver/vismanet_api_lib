<?php
/**
 * CustomerInvoiceApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * CustomerInvoiceApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CustomerInvoiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation customerInvoiceCreate
     *
     * Create an Invoice. Method is deprecated and will be removed starting May 2021 - start using new method CustomerInvoiceV2 endpoint.
     *
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoiceCreate($invoice)
    {
        list($response) = $this->customerInvoiceCreateWithHttpInfo($invoice);
        return $response;
    }

    /**
     * Operation customerInvoiceCreateWithHttpInfo
     *
     * Create an Invoice. Method is deprecated and will be removed starting May 2021 - start using new method CustomerInvoiceV2 endpoint.
     *
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceCreateWithHttpInfo($invoice)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateRequest($invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceCreateAsync
     *
     * Create an Invoice. Method is deprecated and will be removed starting May 2021 - start using new method CustomerInvoiceV2 endpoint.
     *
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateAsync($invoice)
    {
        return $this->customerInvoiceCreateAsyncWithHttpInfo($invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceCreateAsyncWithHttpInfo
     *
     * Create an Invoice. Method is deprecated and will be removed starting May 2021 - start using new method CustomerInvoiceV2 endpoint.
     *
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateAsyncWithHttpInfo($invoice)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateRequest($invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceCreate'
     *
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceCreateRequest($invoice)
    {
        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling customerInvoiceCreate'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceCreateHeaderAttachmentByinvoiceNumber
     *
     * Creates an attachment and associates it with an invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoiceCreateHeaderAttachmentByinvoiceNumber($invoice_number)
    {
        list($response) = $this->customerInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation customerInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo
     *
     * Creates an attachment and associates it with an invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceCreateHeaderAttachmentByinvoiceNumberAsync
     *
     * Creates an attachment and associates it with an invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateHeaderAttachmentByinvoiceNumberAsync($invoice_number)
    {
        return $this->customerInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with an invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceCreateHeaderAttachmentByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceCreateHeaderAttachmentByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumber
     *
     * Creates an attachment and associates it with a certain invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumber($invoice_number, $line_number)
    {
        list($response) = $this->customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number);
        return $response;
    }

    /**
     * Operation customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync($invoice_number, $line_number)
    {
        return $this->customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
     *
     * @param  string $invoice_number Identifies the invoice (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }
        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling customerInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceDeleteByinvoiceNumber
     *
     * Deletes a specific Customer Invoice
     *
     * @param  string $invoice_number Identifies the Customer Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoiceDeleteByinvoiceNumber($invoice_number)
    {
        list($response) = $this->customerInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation customerInvoiceDeleteByinvoiceNumberWithHttpInfo
     *
     * Deletes a specific Customer Invoice
     *
     * @param  string $invoice_number Identifies the Customer Invoice to delete (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceDeleteByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceDeleteByinvoiceNumberAsync
     *
     * Deletes a specific Customer Invoice
     *
     * @param  string $invoice_number Identifies the Customer Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceDeleteByinvoiceNumberAsync($invoice_number)
    {
        return $this->customerInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo
     *
     * Deletes a specific Customer Invoice
     *
     * @param  string $invoice_number Identifies the Customer Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceDeleteByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceDeleteByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Customer Invoice to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceDeleteByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceDeleteByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceGetAll
     *
     * Get a range of Invoices - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size  Change log:  2020-May:Added forced pagination
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\CustomerInvoiceDto[]
     */
    public function customerInvoiceGetAll($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->customerInvoiceGetAllWithHttpInfo($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation customerInvoiceGetAllWithHttpInfo
     *
     * Get a range of Invoices - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size  Change log:  2020-May:Added forced pagination
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\CustomerInvoiceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceGetAllWithHttpInfo($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto[]';
        $request = $this->customerInvoiceGetAllRequest($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceGetAllAsync
     *
     * Get a range of Invoices - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size  Change log:  2020-May:Added forced pagination
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetAllAsync($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        return $this->customerInvoiceGetAllAsyncWithHttpInfo($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceGetAllAsyncWithHttpInfo
     *
     * Get a range of Invoices - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size  Change log:  2020-May:Added forced pagination
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetAllAsyncWithHttpInfo($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto[]';
        $request = $this->customerInvoiceGetAllRequest($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceGetAll'
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceGetAllRequest($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v1/customerinvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($released !== null) {
            $queryParams['released'] = ObjectSerializer::toQueryValue($released);
        }
        // query params
        if ($dunning_level !== null) {
            $queryParams['dunningLevel'] = ObjectSerializer::toQueryValue($dunning_level);
        }
        // query params
        if ($closed_financial_period !== null) {
            $queryParams['closedFinancialPeriod'] = ObjectSerializer::toQueryValue($closed_financial_period);
        }
        // query params
        if ($dunning_letter_date_time !== null) {
            $queryParams['dunningLetterDateTime'] = ObjectSerializer::toQueryValue($dunning_letter_date_time);
        }
        // query params
        if ($dunning_letter_date_time_condition !== null) {
            $queryParams['dunningLetterDateTimeCondition'] = ObjectSerializer::toQueryValue($dunning_letter_date_time_condition);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($expand_applications !== null) {
            $queryParams['expandApplications'] = ObjectSerializer::toQueryValue($expand_applications);
        }
        // query params
        if ($expand_dunning_information !== null) {
            $queryParams['expandDunningInformation'] = ObjectSerializer::toQueryValue($expand_dunning_information);
        }
        // query params
        if ($expand_attachments !== null) {
            $queryParams['expandAttachments'] = ObjectSerializer::toQueryValue($expand_attachments);
        }
        // query params
        if ($expand_tax_details !== null) {
            $queryParams['expandTaxDetails'] = ObjectSerializer::toQueryValue($expand_tax_details);
        }
        // query params
        if ($expand_invoice_address !== null) {
            $queryParams['expandInvoiceAddress'] = ObjectSerializer::toQueryValue($expand_invoice_address);
        }
        // query params
        if ($financial_period !== null) {
            $queryParams['financialPeriod'] = ObjectSerializer::toQueryValue($financial_period);
        }
        // query params
        if ($document_due_date !== null) {
            $queryParams['documentDueDate'] = ObjectSerializer::toQueryValue($document_due_date);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($external_reference !== null) {
            $queryParams['externalReference'] = ObjectSerializer::toQueryValue($external_reference);
        }
        // query params
        if ($payment_reference !== null) {
            $queryParams['paymentReference'] = ObjectSerializer::toQueryValue($payment_reference);
        }
        // query params
        if ($customer_ref_number !== null) {
            $queryParams['customerRefNumber'] = ObjectSerializer::toQueryValue($customer_ref_number);
        }
        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($created_date_time !== null) {
            $queryParams['createdDateTime'] = ObjectSerializer::toQueryValue($created_date_time);
        }
        // query params
        if ($created_date_time_condition !== null) {
            $queryParams['createdDateTimeCondition'] = ObjectSerializer::toQueryValue($created_date_time_condition);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceGetByinvoiceNumber
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\CustomerInvoiceDto
     */
    public function customerInvoiceGetByinvoiceNumber($invoice_number)
    {
        list($response) = $this->customerInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation customerInvoiceGetByinvoiceNumberWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\CustomerInvoiceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto';
        $request = $this->customerInvoiceGetByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceGetByinvoiceNumberAsync
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetByinvoiceNumberAsync($invoice_number)
    {
        return $this->customerInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceGetByinvoiceNumberAsyncWithHttpInfo
     *
     * Get a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerInvoiceDto';
        $request = $this->customerInvoiceGetByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceGetByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceGetByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceGetByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceGetRotRutByrefNbr
     *
     * Get Rot Rut informations for a Customer Invoice
     *
     * @param  string $ref_nbr Identify the customer invoice for which to return data (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\RotRutDto
     */
    public function customerInvoiceGetRotRutByrefNbr($ref_nbr)
    {
        list($response) = $this->customerInvoiceGetRotRutByrefNbrWithHttpInfo($ref_nbr);
        return $response;
    }

    /**
     * Operation customerInvoiceGetRotRutByrefNbrWithHttpInfo
     *
     * Get Rot Rut informations for a Customer Invoice
     *
     * @param  string $ref_nbr Identify the customer invoice for which to return data (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\RotRutDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceGetRotRutByrefNbrWithHttpInfo($ref_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\RotRutDto';
        $request = $this->customerInvoiceGetRotRutByrefNbrRequest($ref_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\RotRutDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceGetRotRutByrefNbrAsync
     *
     * Get Rot Rut informations for a Customer Invoice
     *
     * @param  string $ref_nbr Identify the customer invoice for which to return data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetRotRutByrefNbrAsync($ref_nbr)
    {
        return $this->customerInvoiceGetRotRutByrefNbrAsyncWithHttpInfo($ref_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceGetRotRutByrefNbrAsyncWithHttpInfo
     *
     * Get Rot Rut informations for a Customer Invoice
     *
     * @param  string $ref_nbr Identify the customer invoice for which to return data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetRotRutByrefNbrAsyncWithHttpInfo($ref_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\RotRutDto';
        $request = $this->customerInvoiceGetRotRutByrefNbrRequest($ref_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceGetRotRutByrefNbr'
     *
     * @param  string $ref_nbr Identify the customer invoice for which to return data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceGetRotRutByrefNbrRequest($ref_nbr)
    {
        // verify the required parameter 'ref_nbr' is set
        if ($ref_nbr === null || (is_array($ref_nbr) && count($ref_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ref_nbr when calling customerInvoiceGetRotRutByrefNbr'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{refNbr}/rotrut';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($ref_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'refNbr' . '}',
                ObjectSerializer::toPathValue($ref_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceGetWorkTypes
     *
     * Get all Work Types
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\WorkTypeDto[]
     */
    public function customerInvoiceGetWorkTypes()
    {
        list($response) = $this->customerInvoiceGetWorkTypesWithHttpInfo();
        return $response;
    }

    /**
     * Operation customerInvoiceGetWorkTypesWithHttpInfo
     *
     * Get all Work Types
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\WorkTypeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceGetWorkTypesWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\WorkTypeDto[]';
        $request = $this->customerInvoiceGetWorkTypesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\WorkTypeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceGetWorkTypesAsync
     *
     * Get all Work Types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetWorkTypesAsync()
    {
        return $this->customerInvoiceGetWorkTypesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceGetWorkTypesAsyncWithHttpInfo
     *
     * Get all Work Types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceGetWorkTypesAsyncWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\WorkTypeDto[]';
        $request = $this->customerInvoiceGetWorkTypesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceGetWorkTypes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceGetWorkTypesRequest()
    {

        $resourcePath = '/controller/api/v1/customerinvoice/worktypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoicePrintInvoiceByrefNbr
     *
     * Get the print report of a Customer Invoice
     *
     * @param  string $ref_nbr Identifies the customer invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoicePrintInvoiceByrefNbr($ref_nbr)
    {
        list($response) = $this->customerInvoicePrintInvoiceByrefNbrWithHttpInfo($ref_nbr);
        return $response;
    }

    /**
     * Operation customerInvoicePrintInvoiceByrefNbrWithHttpInfo
     *
     * Get the print report of a Customer Invoice
     *
     * @param  string $ref_nbr Identifies the customer invoice (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoicePrintInvoiceByrefNbrWithHttpInfo($ref_nbr)
    {
        $returnType = 'object';
        $request = $this->customerInvoicePrintInvoiceByrefNbrRequest($ref_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoicePrintInvoiceByrefNbrAsync
     *
     * Get the print report of a Customer Invoice
     *
     * @param  string $ref_nbr Identifies the customer invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoicePrintInvoiceByrefNbrAsync($ref_nbr)
    {
        return $this->customerInvoicePrintInvoiceByrefNbrAsyncWithHttpInfo($ref_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoicePrintInvoiceByrefNbrAsyncWithHttpInfo
     *
     * Get the print report of a Customer Invoice
     *
     * @param  string $ref_nbr Identifies the customer invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoicePrintInvoiceByrefNbrAsyncWithHttpInfo($ref_nbr)
    {
        $returnType = 'object';
        $request = $this->customerInvoicePrintInvoiceByrefNbrRequest($ref_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoicePrintInvoiceByrefNbr'
     *
     * @param  string $ref_nbr Identifies the customer invoice (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoicePrintInvoiceByrefNbrRequest($ref_nbr)
    {
        // verify the required parameter 'ref_nbr' is set
        if ($ref_nbr === null || (is_array($ref_nbr) && count($ref_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ref_nbr when calling customerInvoicePrintInvoiceByrefNbr'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{refNbr}/print';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($ref_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'refNbr' . '}',
                ObjectSerializer::toPathValue($ref_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceReleaseInvoiceByinvoiceNumber
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the invoice to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReleaseInvoiceActionResultDto
     */
    public function customerInvoiceReleaseInvoiceByinvoiceNumber($invoice_number)
    {
        list($response) = $this->customerInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number);
        return $response;
    }

    /**
     * Operation customerInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the invoice to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReleaseInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseInvoiceActionResultDto';
        $request = $this->customerInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReleaseInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceReleaseInvoiceByinvoiceNumberAsync
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the invoice to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceReleaseInvoiceByinvoiceNumberAsync($invoice_number)
    {
        return $this->customerInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the invoice to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseInvoiceActionResultDto';
        $request = $this->customerInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceReleaseInvoiceByinvoiceNumber'
     *
     * @param  string $invoice_number Reference number of the invoice to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceReleaseInvoiceByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceReverseInvoiceByinvoiceNumber
     *
     * Reverse an Invoice
     *
     * @param  string $invoice_number Reference number of the released invoice to be reversed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionDto $reverse_action_dto The action the dto use to condition the action (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionResultDto
     */
    public function customerInvoiceReverseInvoiceByinvoiceNumber($invoice_number, $reverse_action_dto)
    {
        list($response) = $this->customerInvoiceReverseInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $reverse_action_dto);
        return $response;
    }

    /**
     * Operation customerInvoiceReverseInvoiceByinvoiceNumberWithHttpInfo
     *
     * Reverse an Invoice
     *
     * @param  string $invoice_number Reference number of the released invoice to be reversed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionDto $reverse_action_dto The action the dto use to condition the action (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceReverseInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $reverse_action_dto)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReverseInvoiceActionResultDto';
        $request = $this->customerInvoiceReverseInvoiceByinvoiceNumberRequest($invoice_number, $reverse_action_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReverseInvoiceActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceReverseInvoiceByinvoiceNumberAsync
     *
     * Reverse an Invoice
     *
     * @param  string $invoice_number Reference number of the released invoice to be reversed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionDto $reverse_action_dto The action the dto use to condition the action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceReverseInvoiceByinvoiceNumberAsync($invoice_number, $reverse_action_dto)
    {
        return $this->customerInvoiceReverseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $reverse_action_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceReverseInvoiceByinvoiceNumberAsyncWithHttpInfo
     *
     * Reverse an Invoice
     *
     * @param  string $invoice_number Reference number of the released invoice to be reversed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionDto $reverse_action_dto The action the dto use to condition the action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceReverseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $reverse_action_dto)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReverseInvoiceActionResultDto';
        $request = $this->customerInvoiceReverseInvoiceByinvoiceNumberRequest($invoice_number, $reverse_action_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceReverseInvoiceByinvoiceNumber'
     *
     * @param  string $invoice_number Reference number of the released invoice to be reversed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ReverseInvoiceActionDto $reverse_action_dto The action the dto use to condition the action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceReverseInvoiceByinvoiceNumberRequest($invoice_number, $reverse_action_dto)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceReverseInvoiceByinvoiceNumber'
            );
        }
        // verify the required parameter 'reverse_action_dto' is set
        if ($reverse_action_dto === null || (is_array($reverse_action_dto) && count($reverse_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reverse_action_dto when calling customerInvoiceReverseInvoiceByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}/action/reverse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($reverse_action_dto)) {
            $_tempBody = $reverse_action_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerInvoiceUpdateByinvoiceNumber
     *
     * Update a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerInvoiceUpdateByinvoiceNumber($invoice_number, $invoice)
    {
        list($response) = $this->customerInvoiceUpdateByinvoiceNumberWithHttpInfo($invoice_number, $invoice);
        return $response;
    }

    /**
     * Operation customerInvoiceUpdateByinvoiceNumberWithHttpInfo
     *
     * Update a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerInvoiceUpdateByinvoiceNumberWithHttpInfo($invoice_number, $invoice)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceUpdateByinvoiceNumberRequest($invoice_number, $invoice);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerInvoiceUpdateByinvoiceNumberAsync
     *
     * Update a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceUpdateByinvoiceNumberAsync($invoice_number, $invoice)
    {
        return $this->customerInvoiceUpdateByinvoiceNumberAsyncWithHttpInfo($invoice_number, $invoice)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerInvoiceUpdateByinvoiceNumberAsyncWithHttpInfo
     *
     * Update a specific Invoice
     *
     * @param  string $invoice_number Identifies the Invoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerInvoiceUpdateByinvoiceNumberAsyncWithHttpInfo($invoice_number, $invoice)
    {
        $returnType = 'object';
        $request = $this->customerInvoiceUpdateByinvoiceNumberRequest($invoice_number, $invoice);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerInvoiceUpdateByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Invoice to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerInvoiceUpdateDto $invoice Defines the data for the Invoice to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerInvoiceUpdateByinvoiceNumberRequest($invoice_number, $invoice)
    {
        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling customerInvoiceUpdateByinvoiceNumber'
            );
        }
        // verify the required parameter 'invoice' is set
        if ($invoice === null || (is_array($invoice) && count($invoice) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice when calling customerInvoiceUpdateByinvoiceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerinvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($invoice)) {
            $_tempBody = $invoice;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
