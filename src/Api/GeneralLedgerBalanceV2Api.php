<?php
/**
 * GeneralLedgerBalanceV2Api
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * GeneralLedgerBalanceV2Api Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class GeneralLedgerBalanceV2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation generalLedgerBalanceV2GetGeneralLedgerBalances
     *
     * Get a range of General Ledger Balances. Complete documentation can be found under 8.21  release notes.   Please use a page size lower or equal to the allowed max page size which is returned under metadata.   If pagesize is greater than the max page size, it will be limited to max page size.
     *
     * @param  string $period_id Period to retrieve balance for. Mandatory if &#39;LastModifiedDateTime&#39; not provided. Format: &#39;yyyyMM&#39; (optional)
     * @param  string $account Account to retrieve balance for (optional)
     * @param  string $ledger Ledger to retrieve balance for (optional)
     * @param  string $branch Branch to retrieve balance for (optional)
     * @param  string $balance_type Balance Type of the ledger to be exported (optional)
     * @param  bool $toggle_balance_signs Parameter can be used in order to change the balance sign for liability and income accounts (optional)
     * @param  \DateTime $last_modified_date_time When setting this parameter there will be exported only the balances that were changed since the provided date and time.  Mandatory if &#39;PeriodId&#39; is not provided.  Format: &#39;yyyy-MM-dd HH:mm:ss&#39; (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\GeneralLedgerBalanceDto[]
     */
    public function generalLedgerBalanceV2GetGeneralLedgerBalances($period_id = null, $account = null, $ledger = null, $branch = null, $balance_type = null, $toggle_balance_signs = null, $last_modified_date_time = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->generalLedgerBalanceV2GetGeneralLedgerBalancesWithHttpInfo($period_id, $account, $ledger, $branch, $balance_type, $toggle_balance_signs, $last_modified_date_time, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation generalLedgerBalanceV2GetGeneralLedgerBalancesWithHttpInfo
     *
     * Get a range of General Ledger Balances. Complete documentation can be found under 8.21  release notes.   Please use a page size lower or equal to the allowed max page size which is returned under metadata.   If pagesize is greater than the max page size, it will be limited to max page size.
     *
     * @param  string $period_id Period to retrieve balance for. Mandatory if &#39;LastModifiedDateTime&#39; not provided. Format: &#39;yyyyMM&#39; (optional)
     * @param  string $account Account to retrieve balance for (optional)
     * @param  string $ledger Ledger to retrieve balance for (optional)
     * @param  string $branch Branch to retrieve balance for (optional)
     * @param  string $balance_type Balance Type of the ledger to be exported (optional)
     * @param  bool $toggle_balance_signs Parameter can be used in order to change the balance sign for liability and income accounts (optional)
     * @param  \DateTime $last_modified_date_time When setting this parameter there will be exported only the balances that were changed since the provided date and time.  Mandatory if &#39;PeriodId&#39; is not provided.  Format: &#39;yyyy-MM-dd HH:mm:ss&#39; (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\GeneralLedgerBalanceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function generalLedgerBalanceV2GetGeneralLedgerBalancesWithHttpInfo($period_id = null, $account = null, $ledger = null, $branch = null, $balance_type = null, $toggle_balance_signs = null, $last_modified_date_time = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\GeneralLedgerBalanceDto[]';
        $request = $this->generalLedgerBalanceV2GetGeneralLedgerBalancesRequest($period_id, $account, $ledger, $branch, $balance_type, $toggle_balance_signs, $last_modified_date_time, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\GeneralLedgerBalanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generalLedgerBalanceV2GetGeneralLedgerBalancesAsync
     *
     * Get a range of General Ledger Balances. Complete documentation can be found under 8.21  release notes.   Please use a page size lower or equal to the allowed max page size which is returned under metadata.   If pagesize is greater than the max page size, it will be limited to max page size.
     *
     * @param  string $period_id Period to retrieve balance for. Mandatory if &#39;LastModifiedDateTime&#39; not provided. Format: &#39;yyyyMM&#39; (optional)
     * @param  string $account Account to retrieve balance for (optional)
     * @param  string $ledger Ledger to retrieve balance for (optional)
     * @param  string $branch Branch to retrieve balance for (optional)
     * @param  string $balance_type Balance Type of the ledger to be exported (optional)
     * @param  bool $toggle_balance_signs Parameter can be used in order to change the balance sign for liability and income accounts (optional)
     * @param  \DateTime $last_modified_date_time When setting this parameter there will be exported only the balances that were changed since the provided date and time.  Mandatory if &#39;PeriodId&#39; is not provided.  Format: &#39;yyyy-MM-dd HH:mm:ss&#39; (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generalLedgerBalanceV2GetGeneralLedgerBalancesAsync($period_id = null, $account = null, $ledger = null, $branch = null, $balance_type = null, $toggle_balance_signs = null, $last_modified_date_time = null, $page_number = null, $page_size = null)
    {
        return $this->generalLedgerBalanceV2GetGeneralLedgerBalancesAsyncWithHttpInfo($period_id, $account, $ledger, $branch, $balance_type, $toggle_balance_signs, $last_modified_date_time, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generalLedgerBalanceV2GetGeneralLedgerBalancesAsyncWithHttpInfo
     *
     * Get a range of General Ledger Balances. Complete documentation can be found under 8.21  release notes.   Please use a page size lower or equal to the allowed max page size which is returned under metadata.   If pagesize is greater than the max page size, it will be limited to max page size.
     *
     * @param  string $period_id Period to retrieve balance for. Mandatory if &#39;LastModifiedDateTime&#39; not provided. Format: &#39;yyyyMM&#39; (optional)
     * @param  string $account Account to retrieve balance for (optional)
     * @param  string $ledger Ledger to retrieve balance for (optional)
     * @param  string $branch Branch to retrieve balance for (optional)
     * @param  string $balance_type Balance Type of the ledger to be exported (optional)
     * @param  bool $toggle_balance_signs Parameter can be used in order to change the balance sign for liability and income accounts (optional)
     * @param  \DateTime $last_modified_date_time When setting this parameter there will be exported only the balances that were changed since the provided date and time.  Mandatory if &#39;PeriodId&#39; is not provided.  Format: &#39;yyyy-MM-dd HH:mm:ss&#39; (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generalLedgerBalanceV2GetGeneralLedgerBalancesAsyncWithHttpInfo($period_id = null, $account = null, $ledger = null, $branch = null, $balance_type = null, $toggle_balance_signs = null, $last_modified_date_time = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\GeneralLedgerBalanceDto[]';
        $request = $this->generalLedgerBalanceV2GetGeneralLedgerBalancesRequest($period_id, $account, $ledger, $branch, $balance_type, $toggle_balance_signs, $last_modified_date_time, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generalLedgerBalanceV2GetGeneralLedgerBalances'
     *
     * @param  string $period_id Period to retrieve balance for. Mandatory if &#39;LastModifiedDateTime&#39; not provided. Format: &#39;yyyyMM&#39; (optional)
     * @param  string $account Account to retrieve balance for (optional)
     * @param  string $ledger Ledger to retrieve balance for (optional)
     * @param  string $branch Branch to retrieve balance for (optional)
     * @param  string $balance_type Balance Type of the ledger to be exported (optional)
     * @param  bool $toggle_balance_signs Parameter can be used in order to change the balance sign for liability and income accounts (optional)
     * @param  \DateTime $last_modified_date_time When setting this parameter there will be exported only the balances that were changed since the provided date and time.  Mandatory if &#39;PeriodId&#39; is not provided.  Format: &#39;yyyy-MM-dd HH:mm:ss&#39; (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generalLedgerBalanceV2GetGeneralLedgerBalancesRequest($period_id = null, $account = null, $ledger = null, $branch = null, $balance_type = null, $toggle_balance_signs = null, $last_modified_date_time = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v2/generalLedgerBalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($period_id !== null) {
            $queryParams['periodId'] = ObjectSerializer::toQueryValue($period_id);
        }
        // query params
        if ($account !== null) {
            $queryParams['account'] = ObjectSerializer::toQueryValue($account);
        }
        // query params
        if ($ledger !== null) {
            $queryParams['ledger'] = ObjectSerializer::toQueryValue($ledger);
        }
        // query params
        if ($branch !== null) {
            $queryParams['branch'] = ObjectSerializer::toQueryValue($branch);
        }
        // query params
        if ($balance_type !== null) {
            $queryParams['balanceType'] = ObjectSerializer::toQueryValue($balance_type);
        }
        // query params
        if ($toggle_balance_signs !== null) {
            $queryParams['toggleBalanceSigns'] = ObjectSerializer::toQueryValue($toggle_balance_signs);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
