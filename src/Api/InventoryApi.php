<?php
/**
 * InventoryApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * InventoryApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InventoryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation inventoryChangeInventoryNbrActionByinternalId
     *
     * Updates the InventoryNbr for the specified Inventory
     *
     * @param  int $internal_id Internal identifier of the Inventory for which the Inventory Nbr will be changed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionDto $change_inventory_nbr_action_dto Defines the new Inventory number for the Inventory (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionResultDto
     */
    public function inventoryChangeInventoryNbrActionByinternalId($internal_id, $change_inventory_nbr_action_dto)
    {
        list($response) = $this->inventoryChangeInventoryNbrActionByinternalIdWithHttpInfo($internal_id, $change_inventory_nbr_action_dto);
        return $response;
    }

    /**
     * Operation inventoryChangeInventoryNbrActionByinternalIdWithHttpInfo
     *
     * Updates the InventoryNbr for the specified Inventory
     *
     * @param  int $internal_id Internal identifier of the Inventory for which the Inventory Nbr will be changed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionDto $change_inventory_nbr_action_dto Defines the new Inventory number for the Inventory (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryChangeInventoryNbrActionByinternalIdWithHttpInfo($internal_id, $change_inventory_nbr_action_dto)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionResultDto';
        $request = $this->inventoryChangeInventoryNbrActionByinternalIdRequest($internal_id, $change_inventory_nbr_action_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryChangeInventoryNbrActionByinternalIdAsync
     *
     * Updates the InventoryNbr for the specified Inventory
     *
     * @param  int $internal_id Internal identifier of the Inventory for which the Inventory Nbr will be changed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionDto $change_inventory_nbr_action_dto Defines the new Inventory number for the Inventory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryChangeInventoryNbrActionByinternalIdAsync($internal_id, $change_inventory_nbr_action_dto)
    {
        return $this->inventoryChangeInventoryNbrActionByinternalIdAsyncWithHttpInfo($internal_id, $change_inventory_nbr_action_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryChangeInventoryNbrActionByinternalIdAsyncWithHttpInfo
     *
     * Updates the InventoryNbr for the specified Inventory
     *
     * @param  int $internal_id Internal identifier of the Inventory for which the Inventory Nbr will be changed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionDto $change_inventory_nbr_action_dto Defines the new Inventory number for the Inventory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryChangeInventoryNbrActionByinternalIdAsyncWithHttpInfo($internal_id, $change_inventory_nbr_action_dto)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionResultDto';
        $request = $this->inventoryChangeInventoryNbrActionByinternalIdRequest($internal_id, $change_inventory_nbr_action_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryChangeInventoryNbrActionByinternalId'
     *
     * @param  int $internal_id Internal identifier of the Inventory for which the Inventory Nbr will be changed (required)
     * @param  \Ekstralys\VismaNetApi\Model\ChangeInventoryNbrActionDto $change_inventory_nbr_action_dto Defines the new Inventory number for the Inventory (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryChangeInventoryNbrActionByinternalIdRequest($internal_id, $change_inventory_nbr_action_dto)
    {
        // verify the required parameter 'internal_id' is set
        if ($internal_id === null || (is_array($internal_id) && count($internal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $internal_id when calling inventoryChangeInventoryNbrActionByinternalId'
            );
        }
        // verify the required parameter 'change_inventory_nbr_action_dto' is set
        if ($change_inventory_nbr_action_dto === null || (is_array($change_inventory_nbr_action_dto) && count($change_inventory_nbr_action_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_inventory_nbr_action_dto when calling inventoryChangeInventoryNbrActionByinternalId'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/action/changeInventoryNbr/{internalId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($internal_id !== null) {
            $resourcePath = str_replace(
                '{' . 'internalId' . '}',
                ObjectSerializer::toPathValue($internal_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($change_inventory_nbr_action_dto)) {
            $_tempBody = $change_inventory_nbr_action_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCreateInventoryAttachmentByinventoryNumber
     *
     * Creates an attachment and associates it with a Inventory Item. If the file already exists, a new revision is created.
     *
     * @param  string $inventory_number Identifies the Inventory Item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function inventoryCreateInventoryAttachmentByinventoryNumber($inventory_number)
    {
        list($response) = $this->inventoryCreateInventoryAttachmentByinventoryNumberWithHttpInfo($inventory_number);
        return $response;
    }

    /**
     * Operation inventoryCreateInventoryAttachmentByinventoryNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a Inventory Item. If the file already exists, a new revision is created.
     *
     * @param  string $inventory_number Identifies the Inventory Item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCreateInventoryAttachmentByinventoryNumberWithHttpInfo($inventory_number)
    {
        $returnType = 'object';
        $request = $this->inventoryCreateInventoryAttachmentByinventoryNumberRequest($inventory_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCreateInventoryAttachmentByinventoryNumberAsync
     *
     * Creates an attachment and associates it with a Inventory Item. If the file already exists, a new revision is created.
     *
     * @param  string $inventory_number Identifies the Inventory Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCreateInventoryAttachmentByinventoryNumberAsync($inventory_number)
    {
        return $this->inventoryCreateInventoryAttachmentByinventoryNumberAsyncWithHttpInfo($inventory_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCreateInventoryAttachmentByinventoryNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a Inventory Item. If the file already exists, a new revision is created.
     *
     * @param  string $inventory_number Identifies the Inventory Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCreateInventoryAttachmentByinventoryNumberAsyncWithHttpInfo($inventory_number)
    {
        $returnType = 'object';
        $request = $this->inventoryCreateInventoryAttachmentByinventoryNumberRequest($inventory_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCreateInventoryAttachmentByinventoryNumber'
     *
     * @param  string $inventory_number Identifies the Inventory Item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCreateInventoryAttachmentByinventoryNumberRequest($inventory_number)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryCreateInventoryAttachmentByinventoryNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryCreateInventoryCrossReferencesByinventoryNumber
     *
     * Creates a cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function inventoryCreateInventoryCrossReferencesByinventoryNumber($inventory_number, $cross_reference_update_dto)
    {
        list($response) = $this->inventoryCreateInventoryCrossReferencesByinventoryNumberWithHttpInfo($inventory_number, $cross_reference_update_dto);
        return $response;
    }

    /**
     * Operation inventoryCreateInventoryCrossReferencesByinventoryNumberWithHttpInfo
     *
     * Creates a cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryCreateInventoryCrossReferencesByinventoryNumberWithHttpInfo($inventory_number, $cross_reference_update_dto)
    {
        $returnType = 'object';
        $request = $this->inventoryCreateInventoryCrossReferencesByinventoryNumberRequest($inventory_number, $cross_reference_update_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryCreateInventoryCrossReferencesByinventoryNumberAsync
     *
     * Creates a cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCreateInventoryCrossReferencesByinventoryNumberAsync($inventory_number, $cross_reference_update_dto)
    {
        return $this->inventoryCreateInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo($inventory_number, $cross_reference_update_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryCreateInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo
     *
     * Creates a cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryCreateInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo($inventory_number, $cross_reference_update_dto)
    {
        $returnType = 'object';
        $request = $this->inventoryCreateInventoryCrossReferencesByinventoryNumberRequest($inventory_number, $cross_reference_update_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryCreateInventoryCrossReferencesByinventoryNumber'
     *
     * @param  string $inventory_number  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryCreateInventoryCrossReferencesByinventoryNumberRequest($inventory_number, $cross_reference_update_dto)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryCreateInventoryCrossReferencesByinventoryNumber'
            );
        }
        // verify the required parameter 'cross_reference_update_dto' is set
        if ($cross_reference_update_dto === null || (is_array($cross_reference_update_dto) && count($cross_reference_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cross_reference_update_dto when calling inventoryCreateInventoryCrossReferencesByinventoryNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}/crossReferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($cross_reference_update_dto)) {
            $_tempBody = $cross_reference_update_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetAll
     *
     * Get a range of Inventory items - ScreenId=IN202000 and IN202500
     *
     * @param  string $alternate_id Applies for both Stock and Non-stock items.  Some fields in this filter applies only for one of these. (optional)
     * @param  string $inventory_number The Item ID. (optional)
     * @param  int $sales_category The Category ID for the sales category, found on the Attributes tab. (optional)
     * @param  bool $add_cost_price_statistics This filter can be used only for stock items, from the Price/cost information tab. (optional)
     * @param  string $attributes Attributes (additional information) connected to the item. (optional)
     * @param  string $description A brief description of the stock item from the Top part of the window. (optional)
     * @param  string $availability_last_modified_date_time System retrieved information. (optional)
     * @param  string $availability_last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string[] $inventory_types Filter on one or more inventory types: NonStockItem, LaborItem, ServiceItem, ChargeItem, ExpenseItem, FinishedGoodItem, ComponentPartItem or SubassemblyItem (optional)
     * @param  bool $expand_cross_reference These expand fields are by default set to true, but will be changed in the future.   Set to true to retrieve information about the cross-references (item ID and suppliers/customers ID for the item connected to the item. (optional)
     * @param  bool $expand_attachment Set to true to retrieve information about the attachments connected to the item. (optional)
     * @param  bool $expand_attribute Set to true to retrieve the attribute descriptions used for the item. (optional)
     * @param  bool $expand_warehouse_detail Set to true to retrieve information about the warehouse connected to the item. (optional)
     * @param  bool $expand_account_information Set to true to retrieve information about the account information connected to the item. (optional)
     * @param  bool $expand_inventory_units Set to true to retrieve information about the units of measure connected to the item. (optional)
     * @param  bool $expand_supplier_details Set to true to retrieve details about the supplier connected to the item. (optional)
     * @param  bool $expand_sales_categories Set to true to retrieve details about the sales categories connected to the item. (optional)
     * @param  string $attachment_last_modified_date_time System retrieved information for last modified date and time for attachment. (optional)
     * @param  string $attachment_last_modified_date_time_condition System retrieved information for state/condition for attachment. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\InventoryDto[]
     */
    public function inventoryGetAll($alternate_id = null, $inventory_number = null, $sales_category = null, $add_cost_price_statistics = null, $attributes = null, $description = null, $availability_last_modified_date_time = null, $availability_last_modified_date_time_condition = null, $inventory_types = null, $expand_cross_reference = null, $expand_attachment = null, $expand_attribute = null, $expand_warehouse_detail = null, $expand_account_information = null, $expand_inventory_units = null, $expand_supplier_details = null, $expand_sales_categories = null, $attachment_last_modified_date_time = null, $attachment_last_modified_date_time_condition = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->inventoryGetAllWithHttpInfo($alternate_id, $inventory_number, $sales_category, $add_cost_price_statistics, $attributes, $description, $availability_last_modified_date_time, $availability_last_modified_date_time_condition, $inventory_types, $expand_cross_reference, $expand_attachment, $expand_attribute, $expand_warehouse_detail, $expand_account_information, $expand_inventory_units, $expand_supplier_details, $expand_sales_categories, $attachment_last_modified_date_time, $attachment_last_modified_date_time_condition, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation inventoryGetAllWithHttpInfo
     *
     * Get a range of Inventory items - ScreenId=IN202000 and IN202500
     *
     * @param  string $alternate_id Applies for both Stock and Non-stock items.  Some fields in this filter applies only for one of these. (optional)
     * @param  string $inventory_number The Item ID. (optional)
     * @param  int $sales_category The Category ID for the sales category, found on the Attributes tab. (optional)
     * @param  bool $add_cost_price_statistics This filter can be used only for stock items, from the Price/cost information tab. (optional)
     * @param  string $attributes Attributes (additional information) connected to the item. (optional)
     * @param  string $description A brief description of the stock item from the Top part of the window. (optional)
     * @param  string $availability_last_modified_date_time System retrieved information. (optional)
     * @param  string $availability_last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string[] $inventory_types Filter on one or more inventory types: NonStockItem, LaborItem, ServiceItem, ChargeItem, ExpenseItem, FinishedGoodItem, ComponentPartItem or SubassemblyItem (optional)
     * @param  bool $expand_cross_reference These expand fields are by default set to true, but will be changed in the future.   Set to true to retrieve information about the cross-references (item ID and suppliers/customers ID for the item connected to the item. (optional)
     * @param  bool $expand_attachment Set to true to retrieve information about the attachments connected to the item. (optional)
     * @param  bool $expand_attribute Set to true to retrieve the attribute descriptions used for the item. (optional)
     * @param  bool $expand_warehouse_detail Set to true to retrieve information about the warehouse connected to the item. (optional)
     * @param  bool $expand_account_information Set to true to retrieve information about the account information connected to the item. (optional)
     * @param  bool $expand_inventory_units Set to true to retrieve information about the units of measure connected to the item. (optional)
     * @param  bool $expand_supplier_details Set to true to retrieve details about the supplier connected to the item. (optional)
     * @param  bool $expand_sales_categories Set to true to retrieve details about the sales categories connected to the item. (optional)
     * @param  string $attachment_last_modified_date_time System retrieved information for last modified date and time for attachment. (optional)
     * @param  string $attachment_last_modified_date_time_condition System retrieved information for state/condition for attachment. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\InventoryDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetAllWithHttpInfo($alternate_id = null, $inventory_number = null, $sales_category = null, $add_cost_price_statistics = null, $attributes = null, $description = null, $availability_last_modified_date_time = null, $availability_last_modified_date_time_condition = null, $inventory_types = null, $expand_cross_reference = null, $expand_attachment = null, $expand_attribute = null, $expand_warehouse_detail = null, $expand_account_information = null, $expand_inventory_units = null, $expand_supplier_details = null, $expand_sales_categories = null, $attachment_last_modified_date_time = null, $attachment_last_modified_date_time_condition = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryDto[]';
        $request = $this->inventoryGetAllRequest($alternate_id, $inventory_number, $sales_category, $add_cost_price_statistics, $attributes, $description, $availability_last_modified_date_time, $availability_last_modified_date_time_condition, $inventory_types, $expand_cross_reference, $expand_attachment, $expand_attribute, $expand_warehouse_detail, $expand_account_information, $expand_inventory_units, $expand_supplier_details, $expand_sales_categories, $attachment_last_modified_date_time, $attachment_last_modified_date_time_condition, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\InventoryDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetAllAsync
     *
     * Get a range of Inventory items - ScreenId=IN202000 and IN202500
     *
     * @param  string $alternate_id Applies for both Stock and Non-stock items.  Some fields in this filter applies only for one of these. (optional)
     * @param  string $inventory_number The Item ID. (optional)
     * @param  int $sales_category The Category ID for the sales category, found on the Attributes tab. (optional)
     * @param  bool $add_cost_price_statistics This filter can be used only for stock items, from the Price/cost information tab. (optional)
     * @param  string $attributes Attributes (additional information) connected to the item. (optional)
     * @param  string $description A brief description of the stock item from the Top part of the window. (optional)
     * @param  string $availability_last_modified_date_time System retrieved information. (optional)
     * @param  string $availability_last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string[] $inventory_types Filter on one or more inventory types: NonStockItem, LaborItem, ServiceItem, ChargeItem, ExpenseItem, FinishedGoodItem, ComponentPartItem or SubassemblyItem (optional)
     * @param  bool $expand_cross_reference These expand fields are by default set to true, but will be changed in the future.   Set to true to retrieve information about the cross-references (item ID and suppliers/customers ID for the item connected to the item. (optional)
     * @param  bool $expand_attachment Set to true to retrieve information about the attachments connected to the item. (optional)
     * @param  bool $expand_attribute Set to true to retrieve the attribute descriptions used for the item. (optional)
     * @param  bool $expand_warehouse_detail Set to true to retrieve information about the warehouse connected to the item. (optional)
     * @param  bool $expand_account_information Set to true to retrieve information about the account information connected to the item. (optional)
     * @param  bool $expand_inventory_units Set to true to retrieve information about the units of measure connected to the item. (optional)
     * @param  bool $expand_supplier_details Set to true to retrieve details about the supplier connected to the item. (optional)
     * @param  bool $expand_sales_categories Set to true to retrieve details about the sales categories connected to the item. (optional)
     * @param  string $attachment_last_modified_date_time System retrieved information for last modified date and time for attachment. (optional)
     * @param  string $attachment_last_modified_date_time_condition System retrieved information for state/condition for attachment. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetAllAsync($alternate_id = null, $inventory_number = null, $sales_category = null, $add_cost_price_statistics = null, $attributes = null, $description = null, $availability_last_modified_date_time = null, $availability_last_modified_date_time_condition = null, $inventory_types = null, $expand_cross_reference = null, $expand_attachment = null, $expand_attribute = null, $expand_warehouse_detail = null, $expand_account_information = null, $expand_inventory_units = null, $expand_supplier_details = null, $expand_sales_categories = null, $attachment_last_modified_date_time = null, $attachment_last_modified_date_time_condition = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        return $this->inventoryGetAllAsyncWithHttpInfo($alternate_id, $inventory_number, $sales_category, $add_cost_price_statistics, $attributes, $description, $availability_last_modified_date_time, $availability_last_modified_date_time_condition, $inventory_types, $expand_cross_reference, $expand_attachment, $expand_attribute, $expand_warehouse_detail, $expand_account_information, $expand_inventory_units, $expand_supplier_details, $expand_sales_categories, $attachment_last_modified_date_time, $attachment_last_modified_date_time_condition, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetAllAsyncWithHttpInfo
     *
     * Get a range of Inventory items - ScreenId=IN202000 and IN202500
     *
     * @param  string $alternate_id Applies for both Stock and Non-stock items.  Some fields in this filter applies only for one of these. (optional)
     * @param  string $inventory_number The Item ID. (optional)
     * @param  int $sales_category The Category ID for the sales category, found on the Attributes tab. (optional)
     * @param  bool $add_cost_price_statistics This filter can be used only for stock items, from the Price/cost information tab. (optional)
     * @param  string $attributes Attributes (additional information) connected to the item. (optional)
     * @param  string $description A brief description of the stock item from the Top part of the window. (optional)
     * @param  string $availability_last_modified_date_time System retrieved information. (optional)
     * @param  string $availability_last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string[] $inventory_types Filter on one or more inventory types: NonStockItem, LaborItem, ServiceItem, ChargeItem, ExpenseItem, FinishedGoodItem, ComponentPartItem or SubassemblyItem (optional)
     * @param  bool $expand_cross_reference These expand fields are by default set to true, but will be changed in the future.   Set to true to retrieve information about the cross-references (item ID and suppliers/customers ID for the item connected to the item. (optional)
     * @param  bool $expand_attachment Set to true to retrieve information about the attachments connected to the item. (optional)
     * @param  bool $expand_attribute Set to true to retrieve the attribute descriptions used for the item. (optional)
     * @param  bool $expand_warehouse_detail Set to true to retrieve information about the warehouse connected to the item. (optional)
     * @param  bool $expand_account_information Set to true to retrieve information about the account information connected to the item. (optional)
     * @param  bool $expand_inventory_units Set to true to retrieve information about the units of measure connected to the item. (optional)
     * @param  bool $expand_supplier_details Set to true to retrieve details about the supplier connected to the item. (optional)
     * @param  bool $expand_sales_categories Set to true to retrieve details about the sales categories connected to the item. (optional)
     * @param  string $attachment_last_modified_date_time System retrieved information for last modified date and time for attachment. (optional)
     * @param  string $attachment_last_modified_date_time_condition System retrieved information for state/condition for attachment. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetAllAsyncWithHttpInfo($alternate_id = null, $inventory_number = null, $sales_category = null, $add_cost_price_statistics = null, $attributes = null, $description = null, $availability_last_modified_date_time = null, $availability_last_modified_date_time_condition = null, $inventory_types = null, $expand_cross_reference = null, $expand_attachment = null, $expand_attribute = null, $expand_warehouse_detail = null, $expand_account_information = null, $expand_inventory_units = null, $expand_supplier_details = null, $expand_sales_categories = null, $attachment_last_modified_date_time = null, $attachment_last_modified_date_time_condition = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryDto[]';
        $request = $this->inventoryGetAllRequest($alternate_id, $inventory_number, $sales_category, $add_cost_price_statistics, $attributes, $description, $availability_last_modified_date_time, $availability_last_modified_date_time_condition, $inventory_types, $expand_cross_reference, $expand_attachment, $expand_attribute, $expand_warehouse_detail, $expand_account_information, $expand_inventory_units, $expand_supplier_details, $expand_sales_categories, $attachment_last_modified_date_time, $attachment_last_modified_date_time_condition, $number_to_read, $skip_records, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetAll'
     *
     * @param  string $alternate_id Applies for both Stock and Non-stock items.  Some fields in this filter applies only for one of these. (optional)
     * @param  string $inventory_number The Item ID. (optional)
     * @param  int $sales_category The Category ID for the sales category, found on the Attributes tab. (optional)
     * @param  bool $add_cost_price_statistics This filter can be used only for stock items, from the Price/cost information tab. (optional)
     * @param  string $attributes Attributes (additional information) connected to the item. (optional)
     * @param  string $description A brief description of the stock item from the Top part of the window. (optional)
     * @param  string $availability_last_modified_date_time System retrieved information. (optional)
     * @param  string $availability_last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string[] $inventory_types Filter on one or more inventory types: NonStockItem, LaborItem, ServiceItem, ChargeItem, ExpenseItem, FinishedGoodItem, ComponentPartItem or SubassemblyItem (optional)
     * @param  bool $expand_cross_reference These expand fields are by default set to true, but will be changed in the future.   Set to true to retrieve information about the cross-references (item ID and suppliers/customers ID for the item connected to the item. (optional)
     * @param  bool $expand_attachment Set to true to retrieve information about the attachments connected to the item. (optional)
     * @param  bool $expand_attribute Set to true to retrieve the attribute descriptions used for the item. (optional)
     * @param  bool $expand_warehouse_detail Set to true to retrieve information about the warehouse connected to the item. (optional)
     * @param  bool $expand_account_information Set to true to retrieve information about the account information connected to the item. (optional)
     * @param  bool $expand_inventory_units Set to true to retrieve information about the units of measure connected to the item. (optional)
     * @param  bool $expand_supplier_details Set to true to retrieve details about the supplier connected to the item. (optional)
     * @param  bool $expand_sales_categories Set to true to retrieve details about the sales categories connected to the item. (optional)
     * @param  string $attachment_last_modified_date_time System retrieved information for last modified date and time for attachment. (optional)
     * @param  string $attachment_last_modified_date_time_condition System retrieved information for state/condition for attachment. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetAllRequest($alternate_id = null, $inventory_number = null, $sales_category = null, $add_cost_price_statistics = null, $attributes = null, $description = null, $availability_last_modified_date_time = null, $availability_last_modified_date_time_condition = null, $inventory_types = null, $expand_cross_reference = null, $expand_attachment = null, $expand_attribute = null, $expand_warehouse_detail = null, $expand_account_information = null, $expand_inventory_units = null, $expand_supplier_details = null, $expand_sales_categories = null, $attachment_last_modified_date_time = null, $attachment_last_modified_date_time_condition = null, $number_to_read = null, $skip_records = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v1/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($alternate_id !== null) {
            $queryParams['alternateID'] = ObjectSerializer::toQueryValue($alternate_id);
        }
        // query params
        if ($inventory_number !== null) {
            $queryParams['inventoryNumber'] = ObjectSerializer::toQueryValue($inventory_number);
        }
        // query params
        if ($sales_category !== null) {
            $queryParams['salesCategory'] = ObjectSerializer::toQueryValue($sales_category);
        }
        // query params
        if ($add_cost_price_statistics !== null) {
            $queryParams['addCostPriceStatistics'] = ObjectSerializer::toQueryValue($add_cost_price_statistics);
        }
        // query params
        if ($attributes !== null) {
            $queryParams['attributes'] = ObjectSerializer::toQueryValue($attributes);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if ($availability_last_modified_date_time !== null) {
            $queryParams['availabilityLastModifiedDateTime'] = ObjectSerializer::toQueryValue($availability_last_modified_date_time);
        }
        // query params
        if ($availability_last_modified_date_time_condition !== null) {
            $queryParams['availabilityLastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($availability_last_modified_date_time_condition);
        }
        // query params
        if (is_array($inventory_types)) {
            $queryParams['inventoryTypes'] = $inventory_types;
        } else
        if ($inventory_types !== null) {
            $queryParams['inventoryTypes'] = ObjectSerializer::toQueryValue($inventory_types);
        }
        // query params
        if ($expand_cross_reference !== null) {
            $queryParams['expandCrossReference'] = ObjectSerializer::toQueryValue($expand_cross_reference);
        }
        // query params
        if ($expand_attachment !== null) {
            $queryParams['expandAttachment'] = ObjectSerializer::toQueryValue($expand_attachment);
        }
        // query params
        if ($expand_attribute !== null) {
            $queryParams['expandAttribute'] = ObjectSerializer::toQueryValue($expand_attribute);
        }
        // query params
        if ($expand_warehouse_detail !== null) {
            $queryParams['expandWarehouseDetail'] = ObjectSerializer::toQueryValue($expand_warehouse_detail);
        }
        // query params
        if ($expand_account_information !== null) {
            $queryParams['expandAccountInformation'] = ObjectSerializer::toQueryValue($expand_account_information);
        }
        // query params
        if ($expand_inventory_units !== null) {
            $queryParams['expandInventoryUnits'] = ObjectSerializer::toQueryValue($expand_inventory_units);
        }
        // query params
        if ($expand_supplier_details !== null) {
            $queryParams['expandSupplierDetails'] = ObjectSerializer::toQueryValue($expand_supplier_details);
        }
        // query params
        if ($expand_sales_categories !== null) {
            $queryParams['expandSalesCategories'] = ObjectSerializer::toQueryValue($expand_sales_categories);
        }
        // query params
        if ($attachment_last_modified_date_time !== null) {
            $queryParams['attachmentLastModifiedDateTime'] = ObjectSerializer::toQueryValue($attachment_last_modified_date_time);
        }
        // query params
        if ($attachment_last_modified_date_time_condition !== null) {
            $queryParams['attachmentLastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($attachment_last_modified_date_time_condition);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($created_date_time !== null) {
            $queryParams['createdDateTime'] = ObjectSerializer::toQueryValue($created_date_time);
        }
        // query params
        if ($created_date_time_condition !== null) {
            $queryParams['createdDateTimeCondition'] = ObjectSerializer::toQueryValue($created_date_time_condition);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetByinventoryNumber
     *
     * Get a specific Inventory item
     *
     * @param  string $inventory_number Identifies the Inventory item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\InventoryDto
     */
    public function inventoryGetByinventoryNumber($inventory_number)
    {
        list($response) = $this->inventoryGetByinventoryNumberWithHttpInfo($inventory_number);
        return $response;
    }

    /**
     * Operation inventoryGetByinventoryNumberWithHttpInfo
     *
     * Get a specific Inventory item
     *
     * @param  string $inventory_number Identifies the Inventory item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\InventoryDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetByinventoryNumberWithHttpInfo($inventory_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryDto';
        $request = $this->inventoryGetByinventoryNumberRequest($inventory_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\InventoryDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetByinventoryNumberAsync
     *
     * Get a specific Inventory item
     *
     * @param  string $inventory_number Identifies the Inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetByinventoryNumberAsync($inventory_number)
    {
        return $this->inventoryGetByinventoryNumberAsyncWithHttpInfo($inventory_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetByinventoryNumberAsyncWithHttpInfo
     *
     * Get a specific Inventory item
     *
     * @param  string $inventory_number Identifies the Inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetByinventoryNumberAsyncWithHttpInfo($inventory_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryDto';
        $request = $this->inventoryGetByinventoryNumberRequest($inventory_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetByinventoryNumber'
     *
     * @param  string $inventory_number Identifies the Inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetByinventoryNumberRequest($inventory_number)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryGetByinventoryNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetInventoryCrossReferencesByinventoryNumber
     *
     * Get a range of cross-reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceDto[]
     */
    public function inventoryGetInventoryCrossReferencesByinventoryNumber($inventory_number)
    {
        list($response) = $this->inventoryGetInventoryCrossReferencesByinventoryNumberWithHttpInfo($inventory_number);
        return $response;
    }

    /**
     * Operation inventoryGetInventoryCrossReferencesByinventoryNumberWithHttpInfo
     *
     * Get a range of cross-reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetInventoryCrossReferencesByinventoryNumberWithHttpInfo($inventory_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryCrossReferenceDto[]';
        $request = $this->inventoryGetInventoryCrossReferencesByinventoryNumberRequest($inventory_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\InventoryCrossReferenceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetInventoryCrossReferencesByinventoryNumberAsync
     *
     * Get a range of cross-reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryCrossReferencesByinventoryNumberAsync($inventory_number)
    {
        return $this->inventoryGetInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo($inventory_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo
     *
     * Get a range of cross-reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryCrossReferencesByinventoryNumberAsyncWithHttpInfo($inventory_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\InventoryCrossReferenceDto[]';
        $request = $this->inventoryGetInventoryCrossReferencesByinventoryNumberRequest($inventory_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetInventoryCrossReferencesByinventoryNumber'
     *
     * @param  string $inventory_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetInventoryCrossReferencesByinventoryNumberRequest($inventory_number)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryGetInventoryCrossReferencesByinventoryNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}/crossReferences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbr
     *
     * Get a range of barcodes for a specific purchase receipt
     *
     * @param  string $receipt_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\BarCodeDto[]
     */
    public function inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbr($receipt_nbr)
    {
        list($response) = $this->inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrWithHttpInfo($receipt_nbr);
        return $response;
    }

    /**
     * Operation inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrWithHttpInfo
     *
     * Get a range of barcodes for a specific purchase receipt
     *
     * @param  string $receipt_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\BarCodeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrWithHttpInfo($receipt_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrRequest($receipt_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\BarCodeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrAsync
     *
     * Get a range of barcodes for a specific purchase receipt
     *
     * @param  string $receipt_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrAsync($receipt_nbr)
    {
        return $this->inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrAsyncWithHttpInfo
     *
     * Get a range of barcodes for a specific purchase receipt
     *
     * @param  string $receipt_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrAsyncWithHttpInfo($receipt_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrRequest($receipt_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbr'
     *
     * @param  string $receipt_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbrRequest($receipt_nbr)
    {
        // verify the required parameter 'receipt_nbr' is set
        if ($receipt_nbr === null || (is_array($receipt_nbr) && count($receipt_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $receipt_nbr when calling inventoryGetInventoryPOReceiptTakeBarCodesByreceiptNbr'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/barcode/purchasereceipt/{receiptNbr}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($receipt_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'receiptNbr' . '}',
                ObjectSerializer::toPathValue($receipt_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetInventorySalesOrderBarCodesByorderNbr
     *
     * Get a range of barcodes for a specific sales order
     *
     * @param  string $order_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\BarCodeDto[]
     */
    public function inventoryGetInventorySalesOrderBarCodesByorderNbr($order_nbr)
    {
        list($response) = $this->inventoryGetInventorySalesOrderBarCodesByorderNbrWithHttpInfo($order_nbr);
        return $response;
    }

    /**
     * Operation inventoryGetInventorySalesOrderBarCodesByorderNbrWithHttpInfo
     *
     * Get a range of barcodes for a specific sales order
     *
     * @param  string $order_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\BarCodeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetInventorySalesOrderBarCodesByorderNbrWithHttpInfo($order_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventorySalesOrderBarCodesByorderNbrRequest($order_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\BarCodeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetInventorySalesOrderBarCodesByorderNbrAsync
     *
     * Get a range of barcodes for a specific sales order
     *
     * @param  string $order_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventorySalesOrderBarCodesByorderNbrAsync($order_nbr)
    {
        return $this->inventoryGetInventorySalesOrderBarCodesByorderNbrAsyncWithHttpInfo($order_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetInventorySalesOrderBarCodesByorderNbrAsyncWithHttpInfo
     *
     * Get a range of barcodes for a specific sales order
     *
     * @param  string $order_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventorySalesOrderBarCodesByorderNbrAsyncWithHttpInfo($order_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventorySalesOrderBarCodesByorderNbrRequest($order_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetInventorySalesOrderBarCodesByorderNbr'
     *
     * @param  string $order_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetInventorySalesOrderBarCodesByorderNbrRequest($order_nbr)
    {
        // verify the required parameter 'order_nbr' is set
        if ($order_nbr === null || (is_array($order_nbr) && count($order_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_nbr when calling inventoryGetInventorySalesOrderBarCodesByorderNbr'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/barcode/salesorder/{orderNbr}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'orderNbr' . '}',
                ObjectSerializer::toPathValue($order_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetInventoryShipmentBarCodesByshipmentNbr
     *
     * Get a range of barcodes for a specific shipment
     *
     * @param  string $shipment_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\BarCodeDto[]
     */
    public function inventoryGetInventoryShipmentBarCodesByshipmentNbr($shipment_nbr)
    {
        list($response) = $this->inventoryGetInventoryShipmentBarCodesByshipmentNbrWithHttpInfo($shipment_nbr);
        return $response;
    }

    /**
     * Operation inventoryGetInventoryShipmentBarCodesByshipmentNbrWithHttpInfo
     *
     * Get a range of barcodes for a specific shipment
     *
     * @param  string $shipment_nbr  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\BarCodeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetInventoryShipmentBarCodesByshipmentNbrWithHttpInfo($shipment_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryShipmentBarCodesByshipmentNbrRequest($shipment_nbr);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\BarCodeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetInventoryShipmentBarCodesByshipmentNbrAsync
     *
     * Get a range of barcodes for a specific shipment
     *
     * @param  string $shipment_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryShipmentBarCodesByshipmentNbrAsync($shipment_nbr)
    {
        return $this->inventoryGetInventoryShipmentBarCodesByshipmentNbrAsyncWithHttpInfo($shipment_nbr)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetInventoryShipmentBarCodesByshipmentNbrAsyncWithHttpInfo
     *
     * Get a range of barcodes for a specific shipment
     *
     * @param  string $shipment_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryShipmentBarCodesByshipmentNbrAsyncWithHttpInfo($shipment_nbr)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryShipmentBarCodesByshipmentNbrRequest($shipment_nbr);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetInventoryShipmentBarCodesByshipmentNbr'
     *
     * @param  string $shipment_nbr  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetInventoryShipmentBarCodesByshipmentNbrRequest($shipment_nbr)
    {
        // verify the required parameter 'shipment_nbr' is set
        if ($shipment_nbr === null || (is_array($shipment_nbr) && count($shipment_nbr) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_nbr when calling inventoryGetInventoryShipmentBarCodesByshipmentNbr'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/barcode/shipment/{shipmentNbr}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($shipment_nbr !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentNbr' . '}',
                ObjectSerializer::toPathValue($shipment_nbr),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetInventoryStockTakeBarCodesByreferenceNumber
     *
     * Get a range of barcodes for a specific stock count
     *
     * @param  string $reference_number  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\BarCodeDto[]
     */
    public function inventoryGetInventoryStockTakeBarCodesByreferenceNumber($reference_number)
    {
        list($response) = $this->inventoryGetInventoryStockTakeBarCodesByreferenceNumberWithHttpInfo($reference_number);
        return $response;
    }

    /**
     * Operation inventoryGetInventoryStockTakeBarCodesByreferenceNumberWithHttpInfo
     *
     * Get a range of barcodes for a specific stock count
     *
     * @param  string $reference_number  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\BarCodeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetInventoryStockTakeBarCodesByreferenceNumberWithHttpInfo($reference_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryStockTakeBarCodesByreferenceNumberRequest($reference_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\BarCodeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetInventoryStockTakeBarCodesByreferenceNumberAsync
     *
     * Get a range of barcodes for a specific stock count
     *
     * @param  string $reference_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryStockTakeBarCodesByreferenceNumberAsync($reference_number)
    {
        return $this->inventoryGetInventoryStockTakeBarCodesByreferenceNumberAsyncWithHttpInfo($reference_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetInventoryStockTakeBarCodesByreferenceNumberAsyncWithHttpInfo
     *
     * Get a range of barcodes for a specific stock count
     *
     * @param  string $reference_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetInventoryStockTakeBarCodesByreferenceNumberAsyncWithHttpInfo($reference_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\BarCodeDto[]';
        $request = $this->inventoryGetInventoryStockTakeBarCodesByreferenceNumberRequest($reference_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetInventoryStockTakeBarCodesByreferenceNumber'
     *
     * @param  string $reference_number  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetInventoryStockTakeBarCodesByreferenceNumberRequest($reference_number)
    {
        // verify the required parameter 'reference_number' is set
        if ($reference_number === null || (is_array($reference_number) && count($reference_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reference_number when calling inventoryGetInventoryStockTakeBarCodesByreferenceNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/barcode/stocktake/{referenceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($reference_number !== null) {
            $resourcePath = str_replace(
                '{' . 'referenceNumber' . '}',
                ObjectSerializer::toPathValue($reference_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetItemClasses
     *
     * Get Inventory Item Classes
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ItemClassDto[]
     */
    public function inventoryGetItemClasses()
    {
        list($response) = $this->inventoryGetItemClassesWithHttpInfo();
        return $response;
    }

    /**
     * Operation inventoryGetItemClassesWithHttpInfo
     *
     * Get Inventory Item Classes
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ItemClassDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetItemClassesWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ItemClassDto[]';
        $request = $this->inventoryGetItemClassesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ItemClassDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetItemClassesAsync
     *
     * Get Inventory Item Classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetItemClassesAsync()
    {
        return $this->inventoryGetItemClassesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetItemClassesAsyncWithHttpInfo
     *
     * Get Inventory Item Classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetItemClassesAsyncWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ItemClassDto[]';
        $request = $this->inventoryGetItemClassesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetItemClasses'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetItemClassesRequest()
    {

        $resourcePath = '/controller/api/v1/inventory/itemClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetItemPostClasses
     *
     * Get Inventory Item Post Classes
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\PostingClassDto[]
     */
    public function inventoryGetItemPostClasses()
    {
        list($response) = $this->inventoryGetItemPostClassesWithHttpInfo();
        return $response;
    }

    /**
     * Operation inventoryGetItemPostClassesWithHttpInfo
     *
     * Get Inventory Item Post Classes
     *
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\PostingClassDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetItemPostClassesWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PostingClassDto[]';
        $request = $this->inventoryGetItemPostClassesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\PostingClassDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetItemPostClassesAsync
     *
     * Get Inventory Item Post Classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetItemPostClassesAsync()
    {
        return $this->inventoryGetItemPostClassesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetItemPostClassesAsyncWithHttpInfo
     *
     * Get Inventory Item Post Classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetItemPostClassesAsyncWithHttpInfo()
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\PostingClassDto[]';
        $request = $this->inventoryGetItemPostClassesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetItemPostClasses'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetItemPostClassesRequest()
    {

        $resourcePath = '/controller/api/v1/inventory/itemPostClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryGetSpecificItemClassByitemClassNumber
     *
     * Get Specific Inventory Item Class
     *
     * @param  string $item_class_number item_class_number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ItemClassDto
     */
    public function inventoryGetSpecificItemClassByitemClassNumber($item_class_number)
    {
        list($response) = $this->inventoryGetSpecificItemClassByitemClassNumberWithHttpInfo($item_class_number);
        return $response;
    }

    /**
     * Operation inventoryGetSpecificItemClassByitemClassNumberWithHttpInfo
     *
     * Get Specific Inventory Item Class
     *
     * @param  string $item_class_number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ItemClassDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryGetSpecificItemClassByitemClassNumberWithHttpInfo($item_class_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ItemClassDto';
        $request = $this->inventoryGetSpecificItemClassByitemClassNumberRequest($item_class_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ItemClassDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryGetSpecificItemClassByitemClassNumberAsync
     *
     * Get Specific Inventory Item Class
     *
     * @param  string $item_class_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetSpecificItemClassByitemClassNumberAsync($item_class_number)
    {
        return $this->inventoryGetSpecificItemClassByitemClassNumberAsyncWithHttpInfo($item_class_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryGetSpecificItemClassByitemClassNumberAsyncWithHttpInfo
     *
     * Get Specific Inventory Item Class
     *
     * @param  string $item_class_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryGetSpecificItemClassByitemClassNumberAsyncWithHttpInfo($item_class_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ItemClassDto';
        $request = $this->inventoryGetSpecificItemClassByitemClassNumberRequest($item_class_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryGetSpecificItemClassByitemClassNumber'
     *
     * @param  string $item_class_number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryGetSpecificItemClassByitemClassNumberRequest($item_class_number)
    {
        // verify the required parameter 'item_class_number' is set
        if ($item_class_number === null || (is_array($item_class_number) && count($item_class_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_class_number when calling inventoryGetSpecificItemClassByitemClassNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/itemclass/{itemClassNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_class_number !== null) {
            $resourcePath = str_replace(
                '{' . 'itemClassNumber' . '}',
                ObjectSerializer::toPathValue($item_class_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPost
     *
     * Create an inventory item
     *
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory Define the data for the inventory item to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function inventoryPost($inventory)
    {
        list($response) = $this->inventoryPostWithHttpInfo($inventory);
        return $response;
    }

    /**
     * Operation inventoryPostWithHttpInfo
     *
     * Create an inventory item
     *
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory Define the data for the inventory item to create (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPostWithHttpInfo($inventory)
    {
        $returnType = 'object';
        $request = $this->inventoryPostRequest($inventory);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPostAsync
     *
     * Create an inventory item
     *
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory Define the data for the inventory item to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPostAsync($inventory)
    {
        return $this->inventoryPostAsyncWithHttpInfo($inventory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPostAsyncWithHttpInfo
     *
     * Create an inventory item
     *
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory Define the data for the inventory item to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPostAsyncWithHttpInfo($inventory)
    {
        $returnType = 'object';
        $request = $this->inventoryPostRequest($inventory);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPost'
     *
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory Define the data for the inventory item to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPostRequest($inventory)
    {
        // verify the required parameter 'inventory' is set
        if ($inventory === null || (is_array($inventory) && count($inventory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory when calling inventoryPost'
            );
        }

        $resourcePath = '/controller/api/v1/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($inventory)) {
            $_tempBody = $inventory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryPutByinventoryNumber
     *
     * Update a specific inventory item
     *
     * @param  string $inventory_number Identifies the inventory item to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory The data to update for inventory item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function inventoryPutByinventoryNumber($inventory_number, $inventory)
    {
        list($response) = $this->inventoryPutByinventoryNumberWithHttpInfo($inventory_number, $inventory);
        return $response;
    }

    /**
     * Operation inventoryPutByinventoryNumberWithHttpInfo
     *
     * Update a specific inventory item
     *
     * @param  string $inventory_number Identifies the inventory item to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory The data to update for inventory item (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryPutByinventoryNumberWithHttpInfo($inventory_number, $inventory)
    {
        $returnType = 'object';
        $request = $this->inventoryPutByinventoryNumberRequest($inventory_number, $inventory);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryPutByinventoryNumberAsync
     *
     * Update a specific inventory item
     *
     * @param  string $inventory_number Identifies the inventory item to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory The data to update for inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPutByinventoryNumberAsync($inventory_number, $inventory)
    {
        return $this->inventoryPutByinventoryNumberAsyncWithHttpInfo($inventory_number, $inventory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryPutByinventoryNumberAsyncWithHttpInfo
     *
     * Update a specific inventory item
     *
     * @param  string $inventory_number Identifies the inventory item to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory The data to update for inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryPutByinventoryNumberAsyncWithHttpInfo($inventory_number, $inventory)
    {
        $returnType = 'object';
        $request = $this->inventoryPutByinventoryNumberRequest($inventory_number, $inventory);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryPutByinventoryNumber'
     *
     * @param  string $inventory_number Identifies the inventory item to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryUpdateDto $inventory The data to update for inventory item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryPutByinventoryNumberRequest($inventory_number, $inventory)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryPutByinventoryNumber'
            );
        }
        // verify the required parameter 'inventory' is set
        if ($inventory === null || (is_array($inventory) && count($inventory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory when calling inventoryPutByinventoryNumber'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($inventory)) {
            $_tempBody = $inventory;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpdateCostNonStockItemByinventoryCd
     *
     * Update Cost action on Non-Stock Item
     *
     * @param  string $inventory_cd Identifies the inventory item to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\UpdateCostActionResultDto
     */
    public function inventoryUpdateCostNonStockItemByinventoryCd($inventory_cd)
    {
        list($response) = $this->inventoryUpdateCostNonStockItemByinventoryCdWithHttpInfo($inventory_cd);
        return $response;
    }

    /**
     * Operation inventoryUpdateCostNonStockItemByinventoryCdWithHttpInfo
     *
     * Update Cost action on Non-Stock Item
     *
     * @param  string $inventory_cd Identifies the inventory item to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\UpdateCostActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpdateCostNonStockItemByinventoryCdWithHttpInfo($inventory_cd)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\UpdateCostActionResultDto';
        $request = $this->inventoryUpdateCostNonStockItemByinventoryCdRequest($inventory_cd);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\UpdateCostActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpdateCostNonStockItemByinventoryCdAsync
     *
     * Update Cost action on Non-Stock Item
     *
     * @param  string $inventory_cd Identifies the inventory item to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpdateCostNonStockItemByinventoryCdAsync($inventory_cd)
    {
        return $this->inventoryUpdateCostNonStockItemByinventoryCdAsyncWithHttpInfo($inventory_cd)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpdateCostNonStockItemByinventoryCdAsyncWithHttpInfo
     *
     * Update Cost action on Non-Stock Item
     *
     * @param  string $inventory_cd Identifies the inventory item to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpdateCostNonStockItemByinventoryCdAsyncWithHttpInfo($inventory_cd)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\UpdateCostActionResultDto';
        $request = $this->inventoryUpdateCostNonStockItemByinventoryCdRequest($inventory_cd);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpdateCostNonStockItemByinventoryCd'
     *
     * @param  string $inventory_cd Identifies the inventory item to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpdateCostNonStockItemByinventoryCdRequest($inventory_cd)
    {
        // verify the required parameter 'inventory_cd' is set
        if ($inventory_cd === null || (is_array($inventory_cd) && count($inventory_cd) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_cd when calling inventoryUpdateCostNonStockItemByinventoryCd'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryCd}/action/updateCost';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_cd !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryCd' . '}',
                ObjectSerializer::toPathValue($inventory_cd),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId
     *
     * Updates a specific cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  string $alternate_type  (required)
     * @param  string $alternate_id  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
    {
        list($response) = $this->inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdWithHttpInfo($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto);
        return $response;
    }

    /**
     * Operation inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdWithHttpInfo
     *
     * Updates a specific cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  string $alternate_type  (required)
     * @param  string $alternate_id  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdWithHttpInfo($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
    {
        $returnType = 'object';
        $request = $this->inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdRequest($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdAsync
     *
     * Updates a specific cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  string $alternate_type  (required)
     * @param  string $alternate_id  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdAsync($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
    {
        return $this->inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdAsyncWithHttpInfo($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdAsyncWithHttpInfo
     *
     * Updates a specific cross reference for a specific inventory
     *
     * @param  string $inventory_number  (required)
     * @param  string $alternate_type  (required)
     * @param  string $alternate_id  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdAsyncWithHttpInfo($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
    {
        $returnType = 'object';
        $request = $this->inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdRequest($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId'
     *
     * @param  string $inventory_number  (required)
     * @param  string $alternate_type  (required)
     * @param  string $alternate_id  (required)
     * @param  \Ekstralys\VismaNetApi\Model\InventoryCrossReferenceUpdateDto $cross_reference_update_dto  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateIdRequest($inventory_number, $alternate_type, $alternate_id, $cross_reference_update_dto)
    {
        // verify the required parameter 'inventory_number' is set
        if ($inventory_number === null || (is_array($inventory_number) && count($inventory_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory_number when calling inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId'
            );
        }
        // verify the required parameter 'alternate_type' is set
        if ($alternate_type === null || (is_array($alternate_type) && count($alternate_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alternate_type when calling inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId'
            );
        }
        // verify the required parameter 'alternate_id' is set
        if ($alternate_id === null || (is_array($alternate_id) && count($alternate_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alternate_id when calling inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId'
            );
        }
        // verify the required parameter 'cross_reference_update_dto' is set
        if ($cross_reference_update_dto === null || (is_array($cross_reference_update_dto) && count($cross_reference_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cross_reference_update_dto when calling inventoryUpdateInventoryCrossReferencesByinventoryNumberalternateTypealternateId'
            );
        }

        $resourcePath = '/controller/api/v1/inventory/{inventoryNumber}/crossReferences/{alternateType}/{alternateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($inventory_number !== null) {
            $resourcePath = str_replace(
                '{' . 'inventoryNumber' . '}',
                ObjectSerializer::toPathValue($inventory_number),
                $resourcePath
            );
        }
        // path params
        if ($alternate_type !== null) {
            $resourcePath = str_replace(
                '{' . 'alternateType' . '}',
                ObjectSerializer::toPathValue($alternate_type),
                $resourcePath
            );
        }
        // path params
        if ($alternate_id !== null) {
            $resourcePath = str_replace(
                '{' . 'alternateId' . '}',
                ObjectSerializer::toPathValue($alternate_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($cross_reference_update_dto)) {
            $_tempBody = $cross_reference_update_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
