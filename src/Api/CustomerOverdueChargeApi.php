<?php
/**
 * CustomerOverdueChargeApi
 * PHP version 5
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Visma Net API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 8.43.00.1002
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ekstralys\VismaNetApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Ekstralys\VismaNetApi\ApiException;
use Ekstralys\VismaNetApi\Configuration;
use Ekstralys\VismaNetApi\HeaderSelector;
use Ekstralys\VismaNetApi\ObjectSerializer;

/**
 * CustomerOverdueChargeApi Class Doc Comment
 *
 * @category Class
 * @package  Ekstralys\VismaNetApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CustomerOverdueChargeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumber
     *
     * Creates an attachment and associates it with an overdue charge. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumber($overdue_charge_number)
    {
        list($response) = $this->customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberWithHttpInfo($overdue_charge_number);
        return $response;
    }

    /**
     * Operation customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberWithHttpInfo
     *
     * Creates an attachment and associates it with an overdue charge. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberWithHttpInfo($overdue_charge_number)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberRequest($overdue_charge_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberAsync
     *
     * Creates an attachment and associates it with an overdue charge. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberAsync($overdue_charge_number)
    {
        return $this->customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with an overdue charge. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberRequest($overdue_charge_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumber'
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumberRequest($overdue_charge_number)
    {
        // verify the required parameter 'overdue_charge_number' is set
        if ($overdue_charge_number === null || (is_array($overdue_charge_number) && count($overdue_charge_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge_number when calling customerOverdueChargeCreateHeaderAttachmentByoverdueChargeNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerOverdueCharge/{overdueChargeNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overdue_charge_number !== null) {
            $resourcePath = str_replace(
                '{' . 'overdueChargeNumber' . '}',
                ObjectSerializer::toPathValue($overdue_charge_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumber
     *
     * Creates an attachment and associates it with a certain overdue charge line. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumber($overdue_charge_number, $line_number)
    {
        list($response) = $this->customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberWithHttpInfo($overdue_charge_number, $line_number);
        return $response;
    }

    /**
     * Operation customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain overdue charge line. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberWithHttpInfo($overdue_charge_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberRequest($overdue_charge_number, $line_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain overdue charge line. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberAsync($overdue_charge_number, $line_number)
    {
        return $this->customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberAsyncWithHttpInfo($overdue_charge_number, $line_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain overdue charge line. If the file already exists, a new revision is created.
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberAsyncWithHttpInfo($overdue_charge_number, $line_number)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberRequest($overdue_charge_number, $line_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumber'
     *
     * @param  string $overdue_charge_number Identifies the overdue charge (required)
     * @param  int $line_number Specifies line number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumberRequest($overdue_charge_number, $line_number)
    {
        // verify the required parameter 'overdue_charge_number' is set
        if ($overdue_charge_number === null || (is_array($overdue_charge_number) && count($overdue_charge_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge_number when calling customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumber'
            );
        }
        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling customerOverdueChargeCreateLineAttachmentByoverdueChargeNumberlineNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerOverdueCharge/{overdueChargeNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overdue_charge_number !== null) {
            $resourcePath = str_replace(
                '{' . 'overdueChargeNumber' . '}',
                ObjectSerializer::toPathValue($overdue_charge_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerOverdueChargeGetAll
     *
     * Get a range of Customer Overdue Charges - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto[]
     */
    public function customerOverdueChargeGetAll($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        list($response) = $this->customerOverdueChargeGetAllWithHttpInfo($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);
        return $response;
    }

    /**
     * Operation customerOverdueChargeGetAllWithHttpInfo
     *
     * Get a range of Customer Overdue Charges - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeGetAllWithHttpInfo($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto[]';
        $request = $this->customerOverdueChargeGetAllRequest($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeGetAllAsync
     *
     * Get a range of Customer Overdue Charges - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeGetAllAsync($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        return $this->customerOverdueChargeGetAllAsyncWithHttpInfo($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeGetAllAsyncWithHttpInfo
     *
     * Get a range of Customer Overdue Charges - ScreenId=AR301000  Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeGetAllAsyncWithHttpInfo($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto[]';
        $request = $this->customerOverdueChargeGetAllRequest($document_type, $released, $dunning_level, $closed_financial_period, $dunning_letter_date_time, $dunning_letter_date_time_condition, $project, $expand_applications, $expand_dunning_information, $expand_attachments, $expand_tax_details, $expand_invoice_address, $financial_period, $document_due_date, $status, $number_to_read, $skip_records, $external_reference, $payment_reference, $customer_ref_number, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeGetAll'
     *
     * @param  string $document_type The field is deprecated for specific customer document endpoints. It will only be usable from customer document endpoint. (optional)
     * @param  int $released Parameter for showing if invoice has been released or not. (optional)
     * @param  int $dunning_level The dunning level of the document. (optional)
     * @param  string $closed_financial_period The date of the closing of the financial period. (optional)
     * @param  string $dunning_letter_date_time The date and time for when the document last released a dunning letter. (optional)
     * @param  string $dunning_letter_date_time_condition Set time/date as before (&amp;lt;), after (&amp;gt;), before and including (&#x3D;&amp;lt;) OR after and including (&#x3D;&amp;gt;) to filter on time frame. (optional)
     * @param  string $project The project with which the document is associated. (optional)
     * @param  bool $expand_applications True if you want to see all dunning information regarding this document. (optional)
     * @param  bool $expand_dunning_information (optional)
     * @param  bool $expand_attachments True if you want to see all attachments regarding this document. (optional)
     * @param  bool $expand_tax_details True if you want to see all VAT details regarding this document. (optional)
     * @param  bool $expand_invoice_address True if you want to see all information regarding the invoice address for this document. (optional)
     * @param  string $financial_period The financial period to which the transactions recorded in the document is posted. Format YYYYMM. (optional)
     * @param  \DateTime $document_due_date The date when payment for the document is due, in accordance with the credit terms. (optional)
     * @param  string $status The status of the document. Use the dropdown to select status. (optional)
     * @param  int $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string $external_reference The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $payment_reference The top part &amp;gt; Payment ref. &amp;gt; The reference number of the document, as automatically generated by the system in accordance with the number series assigned to cash sales in the Customer ledger preferences window.. (optional)
     * @param  string $customer_ref_number The top part &amp;gt; External reference &amp;gt; The external reference used in AutoInvoice. (optional)
     * @param  string $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string $last_modified_date_time System generated value for last modification of transaction/record. Use format: YYYY-MM-DD HH:MM (date and time) to filter from date to present. (optional)
     * @param  string $last_modified_date_time_condition System retrieved information for state/condition. (optional)
     * @param  string $created_date_time Creation date and time. (optional)
     * @param  string $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int $page_number Pagination parameter. Page number. (optional)
     * @param  int $page_size Pagination parameter. Number of items to be collected. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeGetAllRequest($document_type = null, $released = null, $dunning_level = null, $closed_financial_period = null, $dunning_letter_date_time = null, $dunning_letter_date_time_condition = null, $project = null, $expand_applications = null, $expand_dunning_information = null, $expand_attachments = null, $expand_tax_details = null, $expand_invoice_address = null, $financial_period = null, $document_due_date = null, $status = null, $number_to_read = null, $skip_records = null, $external_reference = null, $payment_reference = null, $customer_ref_number = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null)
    {

        $resourcePath = '/controller/api/v1/customerOverdueCharge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_type !== null) {
            $queryParams['documentType'] = ObjectSerializer::toQueryValue($document_type);
        }
        // query params
        if ($released !== null) {
            $queryParams['released'] = ObjectSerializer::toQueryValue($released);
        }
        // query params
        if ($dunning_level !== null) {
            $queryParams['dunningLevel'] = ObjectSerializer::toQueryValue($dunning_level);
        }
        // query params
        if ($closed_financial_period !== null) {
            $queryParams['closedFinancialPeriod'] = ObjectSerializer::toQueryValue($closed_financial_period);
        }
        // query params
        if ($dunning_letter_date_time !== null) {
            $queryParams['dunningLetterDateTime'] = ObjectSerializer::toQueryValue($dunning_letter_date_time);
        }
        // query params
        if ($dunning_letter_date_time_condition !== null) {
            $queryParams['dunningLetterDateTimeCondition'] = ObjectSerializer::toQueryValue($dunning_letter_date_time_condition);
        }
        // query params
        if ($project !== null) {
            $queryParams['project'] = ObjectSerializer::toQueryValue($project);
        }
        // query params
        if ($expand_applications !== null) {
            $queryParams['expandApplications'] = ObjectSerializer::toQueryValue($expand_applications);
        }
        // query params
        if ($expand_dunning_information !== null) {
            $queryParams['expandDunningInformation'] = ObjectSerializer::toQueryValue($expand_dunning_information);
        }
        // query params
        if ($expand_attachments !== null) {
            $queryParams['expandAttachments'] = ObjectSerializer::toQueryValue($expand_attachments);
        }
        // query params
        if ($expand_tax_details !== null) {
            $queryParams['expandTaxDetails'] = ObjectSerializer::toQueryValue($expand_tax_details);
        }
        // query params
        if ($expand_invoice_address !== null) {
            $queryParams['expandInvoiceAddress'] = ObjectSerializer::toQueryValue($expand_invoice_address);
        }
        // query params
        if ($financial_period !== null) {
            $queryParams['financialPeriod'] = ObjectSerializer::toQueryValue($financial_period);
        }
        // query params
        if ($document_due_date !== null) {
            $queryParams['documentDueDate'] = ObjectSerializer::toQueryValue($document_due_date);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($number_to_read !== null) {
            $queryParams['numberToRead'] = ObjectSerializer::toQueryValue($number_to_read);
        }
        // query params
        if ($skip_records !== null) {
            $queryParams['skipRecords'] = ObjectSerializer::toQueryValue($skip_records);
        }
        // query params
        if ($external_reference !== null) {
            $queryParams['externalReference'] = ObjectSerializer::toQueryValue($external_reference);
        }
        // query params
        if ($payment_reference !== null) {
            $queryParams['paymentReference'] = ObjectSerializer::toQueryValue($payment_reference);
        }
        // query params
        if ($customer_ref_number !== null) {
            $queryParams['customerRefNumber'] = ObjectSerializer::toQueryValue($customer_ref_number);
        }
        // query params
        if ($greater_than_value !== null) {
            $queryParams['greaterThanValue'] = ObjectSerializer::toQueryValue($greater_than_value);
        }
        // query params
        if ($last_modified_date_time !== null) {
            $queryParams['lastModifiedDateTime'] = ObjectSerializer::toQueryValue($last_modified_date_time);
        }
        // query params
        if ($last_modified_date_time_condition !== null) {
            $queryParams['lastModifiedDateTimeCondition'] = ObjectSerializer::toQueryValue($last_modified_date_time_condition);
        }
        // query params
        if ($created_date_time !== null) {
            $queryParams['createdDateTime'] = ObjectSerializer::toQueryValue($created_date_time);
        }
        // query params
        if ($created_date_time_condition !== null) {
            $queryParams['createdDateTimeCondition'] = ObjectSerializer::toQueryValue($created_date_time_condition);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['pageNumber'] = ObjectSerializer::toQueryValue($page_number);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerOverdueChargeGetByoverdueChargeNumber
     *
     * Get a specific Customer Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Customer Overdue Charge (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto
     */
    public function customerOverdueChargeGetByoverdueChargeNumber($overdue_charge_number)
    {
        list($response) = $this->customerOverdueChargeGetByoverdueChargeNumberWithHttpInfo($overdue_charge_number);
        return $response;
    }

    /**
     * Operation customerOverdueChargeGetByoverdueChargeNumberWithHttpInfo
     *
     * Get a specific Customer Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Customer Overdue Charge (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeGetByoverdueChargeNumberWithHttpInfo($overdue_charge_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto';
        $request = $this->customerOverdueChargeGetByoverdueChargeNumberRequest($overdue_charge_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeGetByoverdueChargeNumberAsync
     *
     * Get a specific Customer Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Customer Overdue Charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeGetByoverdueChargeNumberAsync($overdue_charge_number)
    {
        return $this->customerOverdueChargeGetByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeGetByoverdueChargeNumberAsyncWithHttpInfo
     *
     * Get a specific Customer Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Customer Overdue Charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeGetByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\CustomerOverdueChargeDto';
        $request = $this->customerOverdueChargeGetByoverdueChargeNumberRequest($overdue_charge_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeGetByoverdueChargeNumber'
     *
     * @param  string $overdue_charge_number Identifies the Customer Overdue Charge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeGetByoverdueChargeNumberRequest($overdue_charge_number)
    {
        // verify the required parameter 'overdue_charge_number' is set
        if ($overdue_charge_number === null || (is_array($overdue_charge_number) && count($overdue_charge_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge_number when calling customerOverdueChargeGetByoverdueChargeNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerOverdueCharge/{overdueChargeNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overdue_charge_number !== null) {
            $resourcePath = str_replace(
                '{' . 'overdueChargeNumber' . '}',
                ObjectSerializer::toPathValue($overdue_charge_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerOverdueChargeReleaseDocumentByoverdueChargeNumber
     *
     * Release overdue charge operation
     *
     * @param  string $overdue_charge_number Reference number of the overdue charge to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Ekstralys\VismaNetApi\Model\ReleaseCustomerOverdueChargeActionResultDto
     */
    public function customerOverdueChargeReleaseDocumentByoverdueChargeNumber($overdue_charge_number)
    {
        list($response) = $this->customerOverdueChargeReleaseDocumentByoverdueChargeNumberWithHttpInfo($overdue_charge_number);
        return $response;
    }

    /**
     * Operation customerOverdueChargeReleaseDocumentByoverdueChargeNumberWithHttpInfo
     *
     * Release overdue charge operation
     *
     * @param  string $overdue_charge_number Reference number of the overdue charge to be released (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Ekstralys\VismaNetApi\Model\ReleaseCustomerOverdueChargeActionResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeReleaseDocumentByoverdueChargeNumberWithHttpInfo($overdue_charge_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseCustomerOverdueChargeActionResultDto';
        $request = $this->customerOverdueChargeReleaseDocumentByoverdueChargeNumberRequest($overdue_charge_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Ekstralys\VismaNetApi\Model\ReleaseCustomerOverdueChargeActionResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeReleaseDocumentByoverdueChargeNumberAsync
     *
     * Release overdue charge operation
     *
     * @param  string $overdue_charge_number Reference number of the overdue charge to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeReleaseDocumentByoverdueChargeNumberAsync($overdue_charge_number)
    {
        return $this->customerOverdueChargeReleaseDocumentByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeReleaseDocumentByoverdueChargeNumberAsyncWithHttpInfo
     *
     * Release overdue charge operation
     *
     * @param  string $overdue_charge_number Reference number of the overdue charge to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeReleaseDocumentByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number)
    {
        $returnType = '\Ekstralys\VismaNetApi\Model\ReleaseCustomerOverdueChargeActionResultDto';
        $request = $this->customerOverdueChargeReleaseDocumentByoverdueChargeNumberRequest($overdue_charge_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeReleaseDocumentByoverdueChargeNumber'
     *
     * @param  string $overdue_charge_number Reference number of the overdue charge to be released (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeReleaseDocumentByoverdueChargeNumberRequest($overdue_charge_number)
    {
        // verify the required parameter 'overdue_charge_number' is set
        if ($overdue_charge_number === null || (is_array($overdue_charge_number) && count($overdue_charge_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge_number when calling customerOverdueChargeReleaseDocumentByoverdueChargeNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerOverdueCharge/{overdueChargeNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overdue_charge_number !== null) {
            $resourcePath = str_replace(
                '{' . 'overdueChargeNumber' . '}',
                ObjectSerializer::toPathValue($overdue_charge_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerOverdueChargeUpdateByoverdueChargeNumber
     *
     * Update a specific Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Overdue Charge to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeUpdateDto $overdue_charge Defines the data for the Overdue Charge to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function customerOverdueChargeUpdateByoverdueChargeNumber($overdue_charge_number, $overdue_charge)
    {
        list($response) = $this->customerOverdueChargeUpdateByoverdueChargeNumberWithHttpInfo($overdue_charge_number, $overdue_charge);
        return $response;
    }

    /**
     * Operation customerOverdueChargeUpdateByoverdueChargeNumberWithHttpInfo
     *
     * Update a specific Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Overdue Charge to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeUpdateDto $overdue_charge Defines the data for the Overdue Charge to update (required)
     *
     * @throws \Ekstralys\VismaNetApi\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerOverdueChargeUpdateByoverdueChargeNumberWithHttpInfo($overdue_charge_number, $overdue_charge)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeUpdateByoverdueChargeNumberRequest($overdue_charge_number, $overdue_charge);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customerOverdueChargeUpdateByoverdueChargeNumberAsync
     *
     * Update a specific Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Overdue Charge to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeUpdateDto $overdue_charge Defines the data for the Overdue Charge to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeUpdateByoverdueChargeNumberAsync($overdue_charge_number, $overdue_charge)
    {
        return $this->customerOverdueChargeUpdateByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number, $overdue_charge)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerOverdueChargeUpdateByoverdueChargeNumberAsyncWithHttpInfo
     *
     * Update a specific Overdue Charge
     *
     * @param  string $overdue_charge_number Identifies the Overdue Charge to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeUpdateDto $overdue_charge Defines the data for the Overdue Charge to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerOverdueChargeUpdateByoverdueChargeNumberAsyncWithHttpInfo($overdue_charge_number, $overdue_charge)
    {
        $returnType = 'object';
        $request = $this->customerOverdueChargeUpdateByoverdueChargeNumberRequest($overdue_charge_number, $overdue_charge);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerOverdueChargeUpdateByoverdueChargeNumber'
     *
     * @param  string $overdue_charge_number Identifies the Overdue Charge to update (required)
     * @param  \Ekstralys\VismaNetApi\Model\CustomerOverdueChargeUpdateDto $overdue_charge Defines the data for the Overdue Charge to update (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customerOverdueChargeUpdateByoverdueChargeNumberRequest($overdue_charge_number, $overdue_charge)
    {
        // verify the required parameter 'overdue_charge_number' is set
        if ($overdue_charge_number === null || (is_array($overdue_charge_number) && count($overdue_charge_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge_number when calling customerOverdueChargeUpdateByoverdueChargeNumber'
            );
        }
        // verify the required parameter 'overdue_charge' is set
        if ($overdue_charge === null || (is_array($overdue_charge) && count($overdue_charge) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overdue_charge when calling customerOverdueChargeUpdateByoverdueChargeNumber'
            );
        }

        $resourcePath = '/controller/api/v1/customerOverdueCharge/{overdueChargeNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($overdue_charge_number !== null) {
            $resourcePath = str_replace(
                '{' . 'overdueChargeNumber' . '}',
                ObjectSerializer::toPathValue($overdue_charge_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($overdue_charge)) {
            $_tempBody = $overdue_charge;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-application-type');
        if ($apiKey !== null) {
            $headers['ipp-application-type'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ipp-company-id');
        if ($apiKey !== null) {
            $headers['ipp-company-id'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
